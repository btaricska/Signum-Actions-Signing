name: Sign JSON via SignServer (produce downloadable signature + outputs)

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  sign:
    runs-on: ubuntu-latest

    env:
      SIGNSERVER_ENDPOINT: "http://signserverdemo.eastus2.cloudapp.azure.com/signserver/rest/v1/workers/PlainSigner/process"
      FILES_DIR: filestosign
      TIMEOUT_SEC: "120"

    # expose job outputs so other jobs can consume them after this job completes
    outputs:
      signature_b64: ${{ steps.create_and_sign.outputs.signature_b64 }}
      signature_path: ${{ steps.create_and_sign.outputs.signature_path }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Create JSON and POST to SignServer (tls validation disabled, not restored) and write outputs
        id: create_and_sign
        shell: pwsh
        run: |
          Write-Host "Using endpoint: $env:SIGNSERVER_ENDPOINT"
          $dir = $env:FILES_DIR
          if (-not (Test-Path -Path $dir)) { New-Item -ItemType Directory -Path $dir | Out-Null }

          # create sample json
          $sample = @{ message = "Hello from GitHub Actions"; timestamp = (Get-Date -Format u) }
          $filePath = Join-Path $dir "file.json"
          $sample | ConvertTo-Json -Depth 5 | Set-Content -Path $filePath -Encoding utf8
          Write-Host "Wrote sample JSON to $filePath"

          # build payload (raw text in data per your requirement)
          $fileText = Get-Content -Path $filePath -Raw -Encoding utf8
          $payloadObj = @{
            metaData = @{
              additionalProp1 = "value1"
              additionalProp2 = "value2"
              additionalProp3 = "value3"
            }
            data = $fileText
          }
          $payload = $payloadObj | ConvertTo-Json -Depth 12

          # --- Disable TLS validation globally for this runner process (DO NOT USE IN PRODUCTION) ---
          Write-Warning "Disabling TLS certificate validation for this process (NOT RESTORING)."
          [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { param($sender,$cert,$chain,$errors) return $true }

          $sigPath = "$filePath.sig"
          $respFile = "$filePath.response.json"
          $sigB64Path = "$filePath.sig.b64"
          $sigHexPath = "$filePath.sig.hex"

          try {
            Write-Host "Posting payload to SignServer with Invoke-RestMethod..."
            $response = Invoke-RestMethod -Uri $env:SIGNSERVER_ENDPOINT -Method Post -Headers @{ 'Content-Type' = 'application/json' } -Body $payload -TimeoutSec ([int]$env:TIMEOUT_SEC) -ErrorAction Stop

            # save raw response for debugging
            if ($null -ne $response) {
              $response | ConvertTo-Json -Depth 10 | Out-File -FilePath $respFile -Encoding utf8
            } else {
              "null" | Out-File -FilePath $respFile -Encoding utf8
            }
            Write-Host "Saved full response to $respFile"

            # Try to extract signature
            $wrote = $false
            $sigBase64 = $null

            if ($response -is [System.Management.Automation.PSCustomObject]) {
              if ($response.PSObject.Properties.Name -contains 'signature') { $candidate = $response.signature }
              elseif ($response.PSObject.Properties.Name -contains 'sig') { $candidate = $response.sig }
              else { $candidate = $null }

              if ($candidate -ne $null) {
                $candidate = [string]$candidate
                # if looks like base64
                if ($candidate -match '^[A-Za-z0-9\+/]+={0,2}$') {
                  try {
                    # write binary signature file
                    [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($candidate))
                    # write base64 text file
                    $candidate | Out-File -FilePath $sigB64Path -Encoding utf8
                    $sigBase64 = $candidate
                    # write hex file
                    $bytes = [Convert]::FromBase64String($candidate)
                    ($bytes | ForEach-Object { $_.ToString("x2") }) -join "" | Out-File -FilePath $sigHexPath -Encoding utf8
                    Write-Host "Saved decoded signature to $sigPath, $sigB64Path, and hex to $sigHexPath"
                    $wrote = $true
                  } catch {
                    Write-Warning "Failed to decode candidate signature: $_"
                  }
                } else {
                  # treat candidate as raw text signature
                  $candidate | Out-File -FilePath $sigPath -Encoding utf8
                  $candidate | Out-File -FilePath $sigB64Path -Encoding utf8
                  Write-Host "Saved raw signature text to $sigPath and $sigB64Path"
                  $sigBase64 = $candidate
                  $wrote = $true
                }
              }
            }

            if (-not $wrote) {
              $respString = $null
              try { $respString = (Get-Content -Path $respFile -Raw -Encoding utf8) } catch {}
              if ($respString -and ($respString -match '^[A-Za-z0-9\+/]+={0,2}$')) {
                try {
                  [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($respString))
                  $respString | Out-File -FilePath $sigB64Path -Encoding utf8
                  $bytes = [Convert]::FromBase64String($respString)
                  ($bytes | ForEach-Object { $_.ToString("x2") }) -join "" | Out-File -FilePath $sigHexPath -Encoding utf8
                  $sigBase64 = $respString
                  Write-Host "Saved decoded signature to $sigPath, $sigB64Path, and hex to $sigHexPath (raw response)"
                  $wrote = $true
                } catch {
                  Write-Warning "Raw response looked like base64 but decode failed: $_"
                }
              }
            }

            if (-not $wrote) {
              # final fallback: save raw response text into .sig and .b64 (text)
              try {
                $respString = (Get-Content -Path $respFile -Raw -Encoding utf8)
                $respString | Out-File -FilePath $sigPath -Encoding utf8
                $respString | Out-File -FilePath $sigB64Path -Encoding utf8
                Write-Host "Saved raw response text to $sigPath and $sigB64Path"
                $sigBase64 = $respString
                $wrote = $true
              } catch {
                Write-Warning "Unable to save raw response to sig: $_"
              }
            }

            if (-not $wrote) {
              Write-Error "Signature extraction failed. Inspect $respFile or runner logs."
              exit 1
            }

            # Expose outputs for later steps / job outputs
            if ($sigBase64 -ne $null) {
              Add-Content -Path $env:GITHUB_OUTPUT -Value "signature_b64<<EOF"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "$sigBase64"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "EOF"
            }

            # expose signature path
            Add-Content -Path $env:GITHUB_OUTPUT -Value "signature_path=$sigPath"

          } catch {
            Write-Error "Exception during REST POST: $_"
            if ($_.Exception -ne $null) {
              try {
                $_.Exception | Out-String | Out-File -FilePath "$filePath.sig.error" -Encoding utf8
                Write-Host "Saved exception info to $filePath.sig.error"
              } catch {}
            }
            exit 1
          }

      - name: Debug print: show signature base64 (first 200 chars)
        shell: bash
        run: |
          if [ -f filestosign/file.json.sig.b64 ]; then
            echo "Signature b64 (first 200 chars):"
            head -c 200 filestosign/file.json.sig.b64 || true
            echo
          else
            echo "No filestosign/file.json.sig.b64 present; falling back to step output"
            echo "${{ steps.create_and_sign.outputs.signature_b64 }}" | head -c 200 || true
            echo
          fi
          echo "signature_path (from step output): ${{ steps.create_and_sign.outputs.signature_path }}"

      - name: Upload signature artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signature-package
          path: |
            filestosign/file.json.sig
            filestosign/file.json.sig.b64
            filestosign/file.json.sig.hex
            filestosign/file.json.response.json
            filestosign/file.json.sig.error
