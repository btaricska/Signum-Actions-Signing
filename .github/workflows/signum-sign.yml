# .github/workflows/windows-signing-with-keyfactor-agent.yml
name: Windows Code Signing (Keyfactor Agent)

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: windows-latest
    env:
      OUT_DIR: signed-output

      # We'll create a random file every run so you never block on repo paths
      FILE_TO_SIGN: file-to-sign.bin

      # Agent MSI
      MSI_LANGUAGE: en-US
      KF_AGENT_MSI_URL: https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi

      # Signum / Keyfactor connection (store these as secrets)
      SIGNUM_HOSTNAME:  ${{ secrets.SIGNUM_HOSTNAME }}
      SIGNUM_CLIENTID:  ${{ secrets.SIGNUM_CLIENTID }}
      SIGNUM_USERNAME:  ${{ secrets.SIGNUM_USERNAME }}
      SIGNUM_PASSWORD:  ${{ secrets.SIGNUM_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show PowerShell
        shell: pwsh
        run: |
          $PSVersionTable.PSVersion

      - name: Prepare output + create random file to sign
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $out = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          New-Item -ItemType Directory -Force -Path $out | Out-Null

          $file = Join-Path $out $env:FILE_TO_SIGN
          $bytes = New-Object byte[] 4096
          (New-Object System.Random).NextBytes($bytes)
          [System.IO.File]::WriteAllBytes($file, $bytes)

          Write-Host "Created file to sign: $file"
          Get-Item $file | Format-List FullName,Length

      - name: Download agent MSI (curl)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $msi = Join-Path $env:GITHUB_WORKSPACE "kf-agent.msi"
          $log = Join-Path $env:GITHUB_WORKSPACE "kf-agent-install.log"

          "MSI_PATH=$msi" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "MSI_LOG=$log"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          Write-Host "Downloading: $env:KF_AGENT_MSI_URL"
          curl -L -o "$msi" "$env:KF_AGENT_MSI_URL"

          if (-not (Test-Path $msi)) { throw "MSI download failed." }
          Write-Host "Downloaded MSI size: $((Get-Item $msi).Length) bytes"

      - name: Install agent MSI (pass required properties)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          if (-not (Test-Path $env:MSI_PATH)) { throw "MSI not found: $env:MSI_PATH" }
          if ([string]::IsNullOrWhiteSpace($env:SIGNUM_HOSTNAME)) { throw "Missing SIGNUM_HOSTNAME" }
          if ([string]::IsNullOrWhiteSpace($env:SIGNUM_CLIENTID)) { throw "Missing SIGNUM_CLIENTID" }

          $rtPrimary = $env:SIGNUM_HOSTNAME
          $clientId  = $env:SIGNUM_CLIENTID
          $lang      = if ([string]::IsNullOrWhiteSpace($env:MSI_LANGUAGE)) { "en-US" } else { $env:MSI_LANGUAGE }

          Write-Host "Installing MSI:"
          Write-Host "  MSI:      $env:MSI_PATH"
          Write-Host "  RTPRIMARY:$rtPrimary"
          Write-Host "  CLIENTID: $clientId"
          Write-Host "  LANGUAGE: $lang"
          Write-Host "  LOG:      $env:MSI_LOG"

          $args = @(
            "/i", "`"$env:MSI_PATH`"",
            "RTPRIMARY=`"$rtPrimary`"",
            "CLIENTID=`"$clientId`"",
            "LANGUAGE=`"$lang`"",
            "/qn",
            "/norestart",
            "/l*v", "`"$env:MSI_LOG`""
          )

          $p = Start-Process -FilePath "msiexec.exe" -ArgumentList $args -Wait -PassThru
          Write-Host "msiexec exit code: $($p.ExitCode)"

          if ($p.ExitCode -ne 0) {
            if (Test-Path $env:MSI_LOG) {
              Write-Host "---- Tail(300): $env:MSI_LOG ----"
              Get-Content $env:MSI_LOG -Tail 300 | ForEach-Object { Write-Host $_ }
            }
            throw "MSI install failed (exit code $($p.ExitCode))."
          }

      - name: Configure agent (run keyfactor-setup.exe if present)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          foreach ($n in @("SIGNUM_HOSTNAME","SIGNUM_CLIENTID","SIGNUM_USERNAME","SIGNUM_PASSWORD")) {
            if ([string]::IsNullOrWhiteSpace((Get-Item "Env:$n" -ErrorAction SilentlyContinue).Value)) {
              throw "Missing required env var: $n"
            }
          }

          $setup = @(
            "C:\Program Files\KeyFactor\keyfactor-setup.exe",
            "C:\Program Files (x86)\KeyFactor\keyfactor-setup.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1

          if ($setup) {
            Write-Host "Using keyfactor-setup: $setup"
            & $setup `
              hostname="$env:SIGNUM_HOSTNAME" `
              clientid="$env:SIGNUM_CLIENTID" `
              username="$env:SIGNUM_USERNAME" `
              password="$env:SIGNUM_PASSWORD" `
              loglevel=HIGH logtype=FILE
          } else {
            Write-Host "keyfactor-setup.exe not found (continuing)."
            Write-Host "Installed folder listing (if exists):"
            if (Test-Path "C:\Program Files\KeyFactor") {
              Get-ChildItem "C:\Program Files\KeyFactor" | Select-Object Name,Length,LastWriteTime | Format-Table -AutoSize
            }
          }

      - name: Restart Keyfactor-ish service (safe; ignore permission denied)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          Set-StrictMode -Version Latest

          $svcs = @()
          try {
            $svcs = Get-CimInstance Win32_Service |
              Where-Object { $_.Name -match 'keyfactor|signum|redtrust|evolium' -or $_.DisplayName -match 'keyfactor|signum|redtrust|evolium' } |
              Sort-Object Name
          } catch {
            Write-Host "Service enumeration failed (continuing): $($_.Exception.Message)"
          }

          if (-not $svcs -or $svcs.Count -eq 0) {
            Write-Host "No matching services found (continuing)."
            exit 0
          }

          $svc = $svcs | Select-Object -First 1
          Write-Host "Restarting: $($svc.Name) ($($svc.DisplayName))"

          try {
            Restart-Service -Name $svc.Name -Force -ErrorAction Stop
            Start-Sleep -Seconds 3
            $st = (Get-Service -Name $svc.Name -ErrorAction Stop).Status
            Write-Host "Status: $st"
          } catch {
            Write-Host "Could not restart service (continuing): $($_.Exception.Message)"
          }

      - name: Find Code Signing certs (LocalMachine\My) -> cert_data.json + env thumbprint
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $eku = [Microsoft.PowerShell.Commands.EnhancedKeyUsageRepresentation]::new(
            'Code Signing','1.3.6.1.5.5.7.3.3'
          )

          $data = Get-ChildItem -Path Cert:\LocalMachine\My |
            Where-Object { $_.EnhancedKeyUsageList -and $_.EnhancedKeyUsageList.Contains($eku) } |
            ForEach-Object {
              [PSCustomObject]@{
                CN         = ($_.Subject -split ',\s*' | Select-Object -First 1) -replace '^CN=',''
                Thumbprint = $_.Thumbprint
                NotAfter   = $_.NotAfter
                HasKey     = $_.HasPrivateKey
                Subject    = $_.Subject
              }
            } |
            Sort-Object HasKey -Descending, NotAfter -Descending

          $data | ConvertTo-Json -Depth 100 | Out-File -FilePath 'cert_data.json' -Encoding utf8
          Write-Host "=== cert_data.json ==="
          Get-Content .\cert_data.json | Write-Host

          if (-not $data -or $data.Count -eq 0) {
            throw "No Code Signing certs found in Cert:\LocalMachine\My"
          }

          $chosen = $data | Where-Object { $_.HasKey } | Select-Object -First 1
          if (-not $chosen) { $chosen = $data | Select-Object -First 1 }

          "SIGNING_THUMBPRINT=$($chosen.Thumbprint)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Chosen thumbprint: $($chosen.Thumbprint)"
          Write-Host "Chosen CN: $($chosen.CN)"
          Write-Host "HasPrivateKey: $($chosen.HasKey)"

      - name: Locate signtool.exe (Windows Kits) + sign with chosen thumbprint
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          if ([string]::IsNullOrWhiteSpace($env:SIGNING_THUMBPRINT)) {
            throw "SIGNING_THUMBPRINT not set."
          }

          $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue).Source
          if (-not $signtool) {
            $candidates = @(
              "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe",
              "C:\Program Files\Windows Kits\10\bin\*\x64\signtool.exe"
            )
            $signtool = Get-ChildItem -Path $candidates -ErrorAction SilentlyContinue |
              Sort-Object FullName -Descending |
              Select-Object -First 1 -ExpandProperty FullName
          }
          if (-not $signtool -or -not (Test-Path $signtool)) {
            throw "signtool.exe not found."
          }

          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          if (-not (Test-Path $file)) { throw "File not found to sign: $file" }

          Write-Host "Using signtool: $signtool"
          Write-Host "Signing: $file"
          Write-Host "Thumbprint: $env:SIGNING_THUMBPRINT"

          & $signtool sign /sha1 $env:SIGNING_THUMBPRINT /fd sha256 /tr http://timestamp.digicert.com /td sha256 "$file"

      - name: Verify signature
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          $sig = Get-AuthenticodeSignature -FilePath $file

          Write-Host "Status: $($sig.Status)"
          if ($sig.SignerCertificate) {
            Write-Host "Subject: $($sig.SignerCertificate.Subject)"
            Write-Host "Thumbprint: $($sig.SignerCertificate.Thumbprint)"
          }

          if ($sig.Status -ne "Valid") {
            throw "Signature not valid: $($sig.Status)"
          }

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-output
          path: ${{ env.OUT_DIR }}
          if-no-files-found: error
