name: Sign File via Signum Agent (Windows, KSP/CSP)

on:
  workflow_dispatch:
    inputs:
      file_to_sign:
        description: "Path to file to sign (relative to repo root)"
        required: false
        default: "hello-world-app.exe"
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign-windows:
    runs-on: windows-2022

    env:
      # Paths / outputs
      OUT_DIR: "signed-output"
      FILE_TO_SIGN: ${{ github.event.inputs.file_to_sign || 'hello-world-app.exe' }}
      SIG_OUT_SUFFIX: ".sig"            # for non-Authenticode signatures if used
      EXPECTED_SUBJECT_FRAGMENT: "CN=CodeSigningCertificate"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          KF_AGENT_MSI_URL: ${{ secrets.KF_AGENT_MSI_URL }}
          CERT_THUMBPRINT: ${{ secrets.CERT_THUMBPRINT || '' }}
        run: |
          $required = @('SIGNUM_HOSTNAME','SIGNUM_CLIENTID','SIGNUM_USERNAME','SIGNUM_PASSWORD','KF_AGENT_MSI_URL')
          $missing = @()
          foreach ($r in $required) {
            if (-not (Get-ChildItem env:$r).Value) { $missing += $r }
          }
          if ($missing.Count -gt 0) { Write-Error "Missing secrets: $($missing -join ', ')" ; exit 1 }
          Write-Host "✅ Secrets validated"

      - name: Install Keyfactor Agent (MSI)
        shell: pwsh
        env:
          KF_AGENT_MSI_URL: ${{ secrets.KF_AGENT_MSI_URL }}
        run: |
          $url = $env:KF_AGENT_MSI_URL.Trim()
          if (-not ($url -match '^https?://')) { Write-Error "KF_AGENT_MSI_URL looks invalid: $url" ; exit 1 }
          $msi = Join-Path $env:TEMP 'keyfactor-agent.msi'
          Invoke-WebRequest -Uri $url -OutFile $msi -UseBasicParsing
          Write-Host "Downloaded to $msi"
          # install silently
          Start-Process msiexec.exe -Wait -ArgumentList "/i `"$msi`" /qn /norestart"
          Write-Host "Installed MSI (dpkg equivalent on Windows)."

      - name: Configure agent (keyfactor-setup) and start service
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          # keyfactor-setup may be installed to PATH by MSI; if not, locate it.
          $kf = Get-Command keyfactor-setup -ErrorAction SilentlyContinue
          if (-not $kf) {
            # common install path - adjust if your MSI installs elsewhere
            $possible = @(
              "C:\Program Files\Keyfactor\Agent\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\Service\keyfactor-setup.exe"
            )
            foreach ($p in $possible) { if (Test-Path $p) { $kf = $p; break } }
          } else {
            $kf = $kf.Path
          }

          if (-not $kf) {
            Write-Host "⚠️ keyfactor-setup not found in PATH; attempting to continue (agent may auto-configure)."
          } else {
            Write-Host "Using keyfactor-setup: $kf"
            & $kf `
              hostname="$env:SIGNUM_HOSTNAME" `
              clientid="$env:SIGNUM_CLIENTID" `
              username="$env:SIGNUM_USERNAME" `
              password="$env:SIGNUM_PASSWORD" `
              loglevel=HIGH logtype=FILE
          }

          # Restart/start the Windows service (service name may vary; try KeyfactorService)
          $svcName = 'KeyfactorService'
          if (Get-Service -Name $svcName -ErrorAction SilentlyContinue) {
            Restart-Service -Name $svcName -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 3
            Write-Host "Service $svcName status: $(Get-Service -Name $svcName).Status"
          } else {
            Write-Host "⚠️ Service $svcName not found; agent may install under different name — listing services:"
            Get-Service | Where-Object {$_.Name -like '*Keyfact*' -or $_.DisplayName -like '*Keyfact*'} | Format-Table -AutoSize
          }

      - name: Wait for agent service to be stable
        shell: pwsh
        run: |
          $svcName = 'KeyfactorService'
          $deadline = (Get-Date).AddMinutes(3)
          while ((Get-Date) -lt $deadline) {
            $svc = Get-Service -Name $svcName -ErrorAction SilentlyContinue
            if ($svc -and $svc.Status -eq 'Running') {
              # require continuous run for 10s
              Start-Sleep -Seconds 10
              $svc2 = Get-Service -Name $svcName -ErrorAction SilentlyContinue
              if ($svc2 -and $svc2.Status -eq 'Running') { Write-Host "✅ $svcName stable and running"; break }
            }
            Start-Sleep -Seconds 2
          }
          if (-not (Get-Service -Name $svcName -ErrorAction SilentlyContinue)) {
            Write-Error "$svcName not found; check installation and logs"; exit 1
          }
          if ((Get-Service -Name $svcName).Status -ne 'Running') {
            Write-Error "$svcName not running after wait; dumping last event logs"
            Get-WinEvent -MaxEvents 200 -FilterHashtable @{LogName='Application'} | Select-Object -First 20
            exit 1
          }

      - name: Verify file to sign exists
        shell: pwsh
        run: |
          if (-not (Test-Path -Path $env:FILE_TO_SIGN)) { Write-Error "File to sign not found: $env:FILE_TO_SIGN"; exit 1 }
          Write-Host "Signing: $env:FILE_TO_SIGN"
          Get-Item $env:FILE_TO_SIGN | Format-List

      - name: Find certificate thumbprint (by secret or subject)
        id: find_cert
        shell: pwsh
        env:
          CERT_THUMBPRINT_SECRET: ${{ secrets.CERT_THUMBPRINT || '' }}
          EXPECTED_SUBJECT_FRAGMENT: ${{ env.EXPECTED_SUBJECT_FRAGMENT }}
        run: |
          # Prefer explicit thumbprint via SECRET
          if ($env:CERT_THUMBPRINT_SECRET -and $env:CERT_THUMBPRINT_SECRET.Trim() -ne "") {
            $tp = $env:CERT_THUMBPRINT_SECRET.Trim().Replace(' ','').ToUpper()
            Write-Host "✅ Using thumbprint from secret: $tp"
            echo "thumbprint=$tp" >> $env:GITHUB_OUTPUT
            exit 0
          }

          # Search LocalMachine\My then CurrentUser\My for subject fragment
          $frag = $env:EXPECTED_SUBJECT_FRAGMENT
          Write-Host "Searching cert stores for subject containing: $frag"

          $found = $null
          $stores = @('LocalMachine','CurrentUser')
          foreach ($s in $stores) {
            $certs = Get-ChildItem -Path Cert:\$s\My -ErrorAction SilentlyContinue
            foreach ($c in $certs) {
              if ($c.Subject -like "*$frag*") {
                $found = $c
                break
              }
            }
            if ($found) { break }
          }

          if (-not $found) {
            # fallback: list a few certs so logs show what is present
            Write-Host "⚠️ No cert matched subject fragment. Available cert subjects (sample):"
            Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            Write-Error "No certificate found matching subject fragment. Set secrets.CERT_THUMBPRINT to a known thumbprint if needed." ; exit 1
          }

          $tp = $found.Thumbprint.Replace(' ','').ToUpper()
          Write-Host "✅ Found cert: $($found.Subject)  Thumbprint: $tp"
          echo "thumbprint=$tp" >> $env:GITHUB_OUTPUT

      - name: Sign with signtool (preferred) or PowerShell fallback
        shell: pwsh
        env:
          THUMBPRINT: ${{ steps.find_cert.outputs.thumbprint }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $thumb = $env:THUMBPRINT
          if (-not $thumb) { Write-Error "No thumbprint available"; exit 1 }

          $file = Resolve-Path -Path $env:FILE_TO_SIGN

          # Try signtool (part of Windows SDK). Use /sha1 with machine store if certificate is in LocalMachine
          $sigtool = Get-Command signtool -ErrorAction SilentlyContinue
          if ($sigtool) {
            Write-Host "✍️ Using signtool to sign"
            # prefer to use machine store (LocalMachine) certificate; /sm selects LocalMachine store
            & signtool sign /sm /s My /sha1 $thumb /tr $env:TIMESTAMP_URL /td sha256 /fd sha256 $file
            if ($LASTEXITCODE -ne 0) { Write-Error "signtool failed with exit $LASTEXITCODE"; exit $LASTEXITCODE }
            Write-Host "✅ signtool completed"
          } else {
            Write-Host "⚠️ signtool not present, falling back to Set-AuthenticodeSignature"
            $cert = Get-ChildItem Cert:\LocalMachine\My | Where-Object { $_.Thumbprint -eq $thumb } `
                    -ErrorAction SilentlyContinue
            if (-not $cert) {
              $cert = Get-ChildItem Cert:\CurrentUser\My | Where-Object { $_.Thumbprint -eq $thumb } -ErrorAction SilentlyContinue
            }
            if (-not $cert) { Write-Error "Could not load cert by thumbprint"; exit 1 }

            # Set-AuthenticodeSignature's TimestampServer parameter takes a URL
            $ts = $env:TIMESTAMP_URL
            $signature = Set-AuthenticodeSignature -FilePath $file -Certificate $cert -TimestampServer $ts
            if ($signature.Status -ne 'Valid') {
              Write-Warning "Signature command returned status: $($signature.Status)"
            } else {
              Write-Host "✅ Signed via Set-AuthenticodeSignature"
            }
          }

          # Copy signed output to OUT_DIR for upload
          $outdir = Join-Path $PWD $env:OUT_DIR
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          Copy-Item -Path $file -Destination (Join-Path $outdir ($file | Split-Path -Leaf)) -Force
          Get-ChildItem $outdir | Format-Table

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-output
          path: ${{ env.OUT_DIR }}/*
