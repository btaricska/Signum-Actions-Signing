name: Sign File via Signum Agent + PKCS11

on:
  workflow_dispatch:
    inputs:
      artifact_name:
        description: "Optional: artifact name to download that contains the file to sign"
        required: false
        default: "ExeToSign"
      file_to_sign:
        description: "Path to file to sign (after artifact download / checkout)"
        required: false
        default: "hello-world-app.exe"
      sign_method:
        description: "Signing method: jsign (default) or openssl (advanced)"
        required: false
        default: "jsign"
      agent_deb_url:
        description: "Direct download URL to keyfactor-agent .deb (optional if secret KF_AGENT_DEB_URL is set)"
        required: false
        default: "https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/linux/4.40.1/amd64_ubuntu22.04_keyfactor-agent-4.40.1-51ecba3-Trust.deb"
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: ubuntu-22.04

    env:
      # Keep your original top envs for continuity (not used by the deb-based flow)
      SIGNUM_AGENT_IMAGE: keyfactor.jfrog.io/dev-oci/signum-agent:4.20.1
      FILES_DIR: filestosign
      CONTAINER_NAME: signum-agent
      DOCKER_CONFIG: ${{ github.workspace }}/.docker

      # PKCS#11 module path (host runner; will be discovered if different)
      PKCS11_MODULE: /usr/lib/libkeyfactorpkcs11.so

      # Optional: expected subject fragment to help humans confirm the right cert is present
      EXPECTED_CERT_SUBJECT: "CN=CodeSigningCertificate"

      # Deb-based signing settings
      JSIGN_DEB_URL: "https://github.com/ebourg/jsign/releases/download/6.0/jsign_6.0_all.deb"
      KF_CFG_PATH: "/etc/keyfactor/config"
      PKCS11_PROVIDER_CFG: "keyfactorpkcs11.cfg"
      OUT_DIR: "signed-output"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate secrets (and pick agent URL)
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          JFROG_DOCKER_AUTH: ${{ secrets.JFROG_DOCKER_AUTH }}
          USER_PIN: ${{ secrets.USER_PIN }}
          # Optional secret; if missing we'll use workflow input
          SECRET_AGENT_URL: ${{ secrets.KF_AGENT_DEB_URL || '' }}
          INPUT_AGENT_URL: ${{ inputs.agent_deb_url }}
        run: |
          set -euo pipefail

          # keep your original required secret checks
          for s in SIGNUM_HOSTNAME SIGNUM_CLIENTID SIGNUM_USERNAME SIGNUM_PASSWORD JFROG_DOCKER_AUTH USER_PIN; do
            if [ -z "${!s:-}" ]; then
              echo "‚ùå Missing secret: $s"
              exit 1
            fi
          done

          # agent URL: secret KF_AGENT_DEB_URL wins; otherwise workflow input
          if [ -n "${SECRET_AGENT_URL:-}" ]; then
            AGENT_URL="${SECRET_AGENT_URL}"
            echo "‚úÖ Using agent URL from secret KF_AGENT_DEB_URL"
          else
            AGENT_URL="${INPUT_AGENT_URL:-}"
            echo "‚úÖ Using agent URL from workflow input agent_deb_url"
          fi

          if [ -z "${AGENT_URL:-}" ]; then
            echo "‚ùå No agent .deb URL available. Set secret KF_AGENT_DEB_URL or input agent_deb_url."
            exit 1
          fi

          echo "‚úÖ Secrets validated"
          echo "‚ÑπÔ∏è USER_PIN present (length ${#USER_PIN})"
          echo "AGENT_URL=${AGENT_URL}" >> $GITHUB_ENV

      # We keep this step (from your file) because it uses your existing secret,
      # but it's not required for the deb-based signing flow. It won't fail if absent.
      - name: Configure Docker auth (optional; only needed for container flow)
        shell: bash
        env:
          JFROG_DOCKER_AUTH: ${{ secrets.JFROG_DOCKER_AUTH }}
        run: |
          set -euo pipefail
          mkdir -p "$DOCKER_CONFIG"
          cat > "$DOCKER_CONFIG/config.json" <<EOF
          {
            "auths": {
              "keyfactor.jfrog.io": {
                "auth": "${JFROG_DOCKER_AUTH}"
              }
            }
          }
          EOF
          echo "‚úÖ Docker auth configured (optional)"

      - name: (Optional) Download artifact that contains file to sign
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.artifact_name != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: .

      - name: Install prerequisites (OpenSC, Java, p11 tools)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            opensc opensc-pkcs11 pcscd libpcsclite1 libccid \
            p11-kit-tools p11-kit \
            default-jre-headless \
            curl ca-certificates

      - name: Install jsign
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL -o jsign.deb "$JSIGN_DEB_URL"
          sudo dpkg -i jsign.deb || (sudo apt-get install -f -y && sudo dpkg -i jsign.deb)

      - name: Download & install Keyfactor Agent (.deb) and start service
        shell: bash
        env:
          AGENT_URL: ${{ env.AGENT_URL }}
        run: |
          set -euo pipefail

          echo "‚¨áÔ∏è Downloading Keyfactor agent .deb from:"
          echo "$AGENT_URL"
          curl -fsSL -o kf-agent.deb "$AGENT_URL"

          echo "üì¶ Installing Keyfactor agent..."
          sudo dpkg -i kf-agent.deb || (sudo apt-get install -f -y && sudo dpkg -i kf-agent.deb)

          echo "üöÄ Enabling & starting KeyfactorService..."
          sudo systemctl daemon-reload || true
          sudo systemctl enable KeyfactorService || true
          sudo systemctl restart KeyfactorService

          echo "‚úÖ Service status (last 80 lines):"
          sudo journalctl -u KeyfactorService -n 80 --no-pager || true

          echo "‚úÖ Listening ports:"
          ss -ltnp || true

      - name: Configure agent (keyfactor-setup) + restart service
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          set -euo pipefail

          # optional logging settings
          echo -e "loglevel=HIGH\nlogtype=FILE" | sudo tee "$KF_CFG_PATH" >/dev/null || true

          sudo keyfactor-setup \
            hostname="$SIGNUM_HOSTNAME" \
            clientid="$SIGNUM_CLIENTID" \
            username="$SIGNUM_USERNAME" \
            password="$SIGNUM_PASSWORD" \
            loglevel=HIGH logtype=FILE

          sudo systemctl restart KeyfactorService

          echo "‚úÖ KeyfactorService restarted."
          ss -ltnp || true

      - name: Locate Keyfactor PKCS#11 module (.so)
        id: find_module
        shell: bash
        run: |
          set -euo pipefail

          # Prefer the documented path, but fall back to discovery
          CANDIDATES=(
            "$PKCS11_MODULE"
            /usr/local/keyfactor/pkcs11/libkeyfactorpkcs11.so
            /usr/lib/libkeyfactorpkcs11.so
            /usr/lib/x86_64-linux-gnu/libkeyfactorpkcs11.so
            /usr/lib64/libkeyfactorpkcs11.so
          )

          FOUND=""
          for p in "${CANDIDATES[@]}"; do
            if [ -f "$p" ]; then
              FOUND="$p"
              break
            fi
          done

          if [ -z "$FOUND" ]; then
            FOUND="$(sudo find / -type f -name 'libkeyfactorpkcs11.so' 2>/dev/null | head -n 1 || true)"
          fi

          if [ -z "$FOUND" ]; then
            echo "‚ùå Could not locate libkeyfactorpkcs11.so on this runner."
            exit 1
          fi

          echo "‚úÖ Found PKCS#11 module at: $FOUND"
          echo "::set-output name=module::$FOUND"

      - name: Write SunPKCS11 provider config for Java tools
        shell: bash
        env:
          MODULE_PATH: ${{ steps.find_module.outputs.module }}
        run: |
          set -euo pipefail
          cat > "$PKCS11_PROVIDER_CFG" <<EOF
          name=Keyfactor
          library=${MODULE_PATH}
          EOF
          echo "‚úÖ Provider config written to $PKCS11_PROVIDER_CFG"
          cat "$PKCS11_PROVIDER_CFG"

      - name: List tokens/certs (signum-util -> p11tool -> pkcs11-tool)
        shell: bash
        env:
          MODULE_PATH: ${{ steps.find_module.outputs.module }}
        run: |
          set -euo pipefail

          echo "=== signum-util? ==="
          if command -v signum-util >/dev/null 2>&1; then
            signum-util --listcertificates || true
            exit 0
          fi
          echo "signum-util not found (expected until added to container; .deb agent path is fine)."

          echo "=== p11tool (22.04+ preferred) ==="
          if command -v p11tool >/dev/null 2>&1; then
            p11tool --list-tokens --provider "${MODULE_PATH}" 2>/dev/null | sed -n '1,200p' || true
          else
            echo "p11tool not found"
          fi

          echo "=== pkcs11-tool (older style) ==="
          if command -v pkcs11-tool >/dev/null 2>&1; then
            pkcs11-tool --module "${MODULE_PATH}" --list-slots --verbose 2>/dev/null || true
            pkcs11-tool --module "${MODULE_PATH}" -O 2>/dev/null || true
          else
            echo "pkcs11-tool not found"
          fi

      - name: Choose certificate alias (uses CERT_ALIAS secret if set)
        id: choose_cert
        shell: bash
        env:
          CERT_ALIAS: ${{ secrets.CERT_ALIAS || '' }}
        run: |
          set -euo pipefail
          if [ -n "${CERT_ALIAS:-}" ]; then
            echo "‚úÖ Using CERT_ALIAS from secrets: $CERT_ALIAS"
            echo "::set-output name=alias::$CERT_ALIAS"
            exit 0
          fi

          echo "üîé Auto-selecting first cert ID from keytool output..."
          KEYTOOL_OUT="$(keytool -list -storetype PKCS11 -providerClass sun.security.pkcs11.SunPKCS11 -providerArg "$PKCS11_PROVIDER_CFG" -storepass NONE 2>/dev/null || true)"
          echo "$KEYTOOL_OUT" | grep -oP '^[0-9A-F]+ - Certificate' || true

          FIRST_ID="$(echo "$KEYTOOL_OUT" | grep -oP '^[0-9A-F]+' | head -n1 || true)"
          if [ -z "${FIRST_ID:-}" ]; then
            echo "‚ùå Could not find any certificate IDs via keytool."
            exit 1
          fi

          echo "‚úÖ Auto-selected cert alias: $FIRST_ID"
          echo "::set-output name=alias::$FIRST_ID"

      - name: Sign file with jsign (Authenticode)
        if: ${{ github.event_name != 'workflow_dispatch' || inputs.sign_method == 'jsign' }}
        shell: bash
        env:
          CERT_ALIAS: ${{ steps.choose_cert.outputs.alias }}
        run: |
          set -euo pipefail

          FILE="${{ inputs.file_to_sign || 'hello-world-app.exe' }}"

          if [ ! -f "$FILE" ]; then
            echo "‚ùå File to sign not found: $FILE"
            echo "Current directory listing:"
            ls -la
            exit 1
          fi

          mkdir -p "$OUT_DIR"
          cp -f "$FILE" "$OUT_DIR/"

          echo "‚úçÔ∏è Signing $OUT_DIR/$(basename "$FILE") using alias: $CERT_ALIAS"
          jsign \
            --storetype PKCS11 \
            --keystore "$PKCS11_PROVIDER_CFG" \
            --storepass NONE \
            --
