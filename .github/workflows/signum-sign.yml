name: Sign File via Signum Agent (Windows, KSP/CSP)

on:
  workflow_dispatch:
    inputs:
      file_to_sign:
        description: "Path to file to sign (relative to repo root)"
        required: false
        default: "hello-world-app.exe"
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign-windows:
    runs-on: windows-2022

    env:
      OUT_DIR: "signed-output"
      FILE_TO_SIGN: ${{ github.event.inputs.file_to_sign || 'hello-world-app.exe' }}
      EXPECTED_SUBJECT_FRAGMENT: "CN=CodeSigningCertificate"

      # Safe default if you don't set vars/secrets.KF_AGENT_MSI_URL
      DEFAULT_AGENT_MSI_URL: "https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi"

      # Optional language/culture for the MSI (installer mentions LANGUAGE = CultureCode)
      MSI_LANGUAGE: "en-US"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve MSI URL (vars -> secrets -> default)
        shell: pwsh
        env:
          MSI_FROM_VARS: ${{ vars.KF_AGENT_MSI_URL || '' }}
          MSI_FROM_SECRETS: ${{ secrets.KF_AGENT_MSI_URL || '' }}
        run: |
          $ErrorActionPreference = "Stop"

          $msi = ($env:MSI_FROM_VARS ?? "").Trim()
          if ([string]::IsNullOrWhiteSpace($msi)) { $msi = ($env:MSI_FROM_SECRETS ?? "").Trim() }
          if ([string]::IsNullOrWhiteSpace($msi)) { $msi = ($env:DEFAULT_AGENT_MSI_URL ?? "").Trim() }

          if (-not ($msi -match '^https?://')) { throw "Resolved MSI URL invalid: '$msi'" }

          "KF_AGENT_MSI_URL=$msi" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "✅ KF_AGENT_MSI_URL = $msi"

      - name: Validate required secrets
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          CERT_THUMBPRINT: ${{ secrets.CERT_THUMBPRINT || '' }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"
          $required = @('SIGNUM_HOSTNAME','SIGNUM_CLIENTID','SIGNUM_USERNAME','SIGNUM_PASSWORD')
          $missing = @()

          foreach ($r in $required) {
            $v = (Get-ChildItem env:$r -ErrorAction SilentlyContinue).Value
            if ([string]::IsNullOrWhiteSpace($v)) { $missing += $r }
          }
          if ($missing.Count -gt 0) { throw "Missing secrets: $($missing -join ', ')" }

          Write-Host "✅ Signum secrets validated"
          if (-not [string]::IsNullOrWhiteSpace($env:CERT_THUMBPRINT)) { Write-Host "ℹ️ CERT_THUMBPRINT provided" }

      - name: Download MSI
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $url = ($env:KF_AGENT_MSI_URL ?? "").Trim()
          if ([string]::IsNullOrWhiteSpace($url)) { throw "KF_AGENT_MSI_URL is empty" }

          $msi = Join-Path $env:TEMP 'keyfactor-agent.msi'
          $log = Join-Path $env:TEMP 'kf-agent-install.log'

          Invoke-WebRequest -Uri $url -OutFile $msi -UseBasicParsing
          try { Unblock-File -Path $msi -ErrorAction SilentlyContinue } catch {}

          "MSI_PATH=$msi" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "MSI_LOG=$log"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          Write-Host "✅ Downloaded MSI to $msi"
          Get-Item $msi | Format-List Name,Length,LastWriteTime

      - name: Install Keyfactor Agent MSI (PASS REQUIRED PARAMETERS)
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
        run: |
          $ErrorActionPreference = "Continue"

          $msi = $env:MSI_PATH
          $log = $env:MSI_LOG
          if (-not (Test-Path $msi)) { throw "MSI not found at $msi" }

          # MSI LaunchConditions require:
          #  - RTPRIMARY (ip_primary_unit)  -> use SIGNUM_HOSTNAME
          #  - CLIENTID (key)              -> use SIGNUM_CLIENTID
          # Optional:
          #  - RTSECONDARY
          #  - CUSTOMERROR
          #  - LANGUAGE (CultureCode)
          $rtPrimary = ($env:SIGNUM_HOSTNAME ?? "").Trim()
          $clientId  = ($env:SIGNUM_CLIENTID ?? "").Trim()

          if ([string]::IsNullOrWhiteSpace($rtPrimary)) { throw "SIGNUM_HOSTNAME empty" }
          if ([string]::IsNullOrWhiteSpace($clientId))  { throw "SIGNUM_CLIENTID empty" }

          $lang = ($env:MSI_LANGUAGE ?? "en-US").Trim()
          $customErr = "GitHubActionsInstall"

          # Try per-machine install first
          $args = @(
            "/i `"$msi`"",
            "ALLUSERS=1",
            "MSIINSTALLPERUSER=0",
            "RTPRIMARY=`"$rtPrimary`"",
            "CLIENTID=`"$clientId`"",
            "LANGUAGE=`"$lang`"",
            "CUSTOMERROR=`"$customErr`"",
            "/qn",
            "/norestart",
            "/l*v `"$log`""
          ) -join " "

          Write-Host "=== msiexec $args ==="
          if (Test-Path $log) { Remove-Item $log -Force -ErrorAction SilentlyContinue }

          $p = Start-Process msiexec.exe -Wait -PassThru -ArgumentList $args
          Write-Host "msiexec exit code: $($p.ExitCode)"

          if ($p.ExitCode -ne 0) {
            Write-Host "---- MSI log tail ----"
            if (Test-Path $log) { Get-Content $log -Tail 200 }

            Write-Host "---- Failure context (Return value 3) ----"
            if (Test-Path $log) {
              $lines = Get-Content $log
              $idx = ($lines | Select-String -Pattern "Return value 3" | Select-Object -First 1).LineNumber
              if ($idx) {
                $start = [Math]::Max(0, $idx - 60)
                $end   = [Math]::Min($lines.Count-1, $idx + 20)
                $lines[$start..$end] | ForEach-Object { $_ }
              }
            }

            throw "MSI install failed with exit code $($p.ExitCode)"
          }

          Write-Host "✅ MSI installed successfully"

      - name: Upload MSI install log (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kf-agent-msi-install-log
          path: ${{ env.MSI_LOG }}

      - name: Configure agent (keyfactor-setup)
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          $kfCmd = Get-Command keyfactor-setup -ErrorAction SilentlyContinue
          $kf = if ($kfCmd) { $kfCmd.Path } else { $null }

          if (-not $kf) {
            $common = @(
              "C:\Program Files\Keyfactor\Agent\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\Service\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\keyfactor-setup.exe"
            )
            foreach ($p in $common) { if (Test-Path $p) { $kf = $p; break } }
          }

          if (-not $kf) {
            $found = Get-ChildItem -Path "C:\Program Files" -Filter "keyfactor-setup.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $kf = $found.FullName }
          }

          if (-not $kf) { throw "keyfactor-setup.exe not found after MSI install." }

          Write-Host "✅ Using keyfactor-setup: $kf"
          & $kf `
            hostname="$env:SIGNUM_HOSTNAME" `
            clientid="$env:SIGNUM_CLIENTID" `
            username="$env:SIGNUM_USERNAME" `
            password="$env:SIGNUM_PASSWORD" `
            loglevel=HIGH logtype=FILE

          # Restart the first Keyfactor-ish service we can find
          $svc = Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Sort-Object Name | Select-Object -First 1
          if (-not $svc) { throw "No Keyfactor service found." }

          Restart-Service -Name $svc.Name -Force
          Start-Sleep -Seconds 3
          $svc2 = Get-Service -Name $svc.Name
          Write-Host "Service $($svc2.Name) status: $($svc2.Status)"
          if ($svc2.Status -ne 'Running') { throw "Service not running after restart." }

      - name: Verify file to sign exists
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (-not (Test-Path -Path $env:FILE_TO_SIGN)) {
            Write-Error "File to sign not found: $env:FILE_TO_SIGN"
            Get-ChildItem -Force
            exit 1
          }
          Write-Host "✅ Signing: $env:FILE_TO_SIGN"

      - name: Find certificate thumbprint (by secret or subject)
        id: find_cert
        shell: pwsh
        env:
          CERT_THUMBPRINT_SECRET: ${{ secrets.CERT_THUMBPRINT || '' }}
          EXPECTED_SUBJECT_FRAGMENT: ${{ env.EXPECTED_SUBJECT_FRAGMENT }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not [string]::IsNullOrWhiteSpace($env:CERT_THUMBPRINT_SECRET)) {
            $tp = $env:CERT_THUMBPRINT_SECRET.Trim().Replace(' ','').ToUpper()
            "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            Write-Host "✅ Using thumbprint from secret"
            exit 0
          }

          $frag = $env:EXPECTED_SUBJECT_FRAGMENT
          $found = $null
          foreach ($store in @('LocalMachine','CurrentUser')) {
            $certs = Get-ChildItem -Path "Cert:\$store\My" -ErrorAction SilentlyContinue
            foreach ($c in $certs) { if ($c.Subject -like "*$frag*") { $found = $c; break } }
            if ($found) { break }
          }

          if (-not $found) {
            Write-Host "Sample cert subjects:"
            Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            throw "No certificate found matching '$frag'. Set secrets.CERT_THUMBPRINT."
          }

          $tp = $found.Thumbprint.Replace(' ','').ToUpper()
          "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "✅ Found certificate: $($found.Subject)"

      - name: Sign with signtool
        shell: pwsh
        env:
          THUMBPRINT: ${{ steps.find_cert.outputs.thumbprint }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"
          $thumb = $env:THUMBPRINT
          if ([string]::IsNullOrWhiteSpace($thumb)) { throw "No thumbprint available." }

          $file = Resolve-Path -Path $env:FILE_TO_SIGN
          $sigtool = Get-Command signtool -ErrorAction SilentlyContinue
          if (-not $sigtool) { throw "signtool not found on runner." }

          & signtool sign /sm /s My /sha1 $thumb /tr $env:TIMESTAMP_URL /td sha256 /fd sha256 $file
          if ($LASTEXITCODE -ne 0) { throw "signtool failed with exit $LASTEXITCODE" }

          $outdir = Join-Path $PWD $env:OUT_DIR
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          Copy-Item -Path $file -Destination (Join-Path $outdir (Split-Path $file -Leaf)) -Force

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-output
          path: signed-output/*
