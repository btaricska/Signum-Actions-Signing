name: Sign File via Signum Agent + PKCS11

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: ubuntu-22.04

    env:
      KF_CFG_PATH: "/etc/keyfactor/config"
      OUT_DIR: "signed-output"
      FILE_TO_SIGN: "file.bin"
      SIG_OUT: "file.bin.sig"

      # If you want to try matching a specific cert subject, set this (optional)
      EXPECTED_SUBJECT_FRAGMENT: "CN=CodeSigningCertificate"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          KF_AGENT_DEB_URL: ${{ secrets.KF_AGENT_DEB_URL }}
          USER_PIN: ${{ secrets.USER_PIN }}
        run: |
          set -euo pipefail
          for s in SIGNUM_HOSTNAME SIGNUM_CLIENTID SIGNUM_USERNAME SIGNUM_PASSWORD KF_AGENT_DEB_URL USER_PIN; do
            if [ -z "${!s:-}" ]; then
              echo "‚ùå Missing secret: $s"
              exit 1
            fi
          done
          echo "‚úÖ Secrets validated"

      - name: Install prerequisites
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            opensc opensc-pkcs11 pcscd libpcsclite1 libccid \
            curl ca-certificates

          command -v pkcs11-tool
          pkcs11-tool --version || true

      - name: Create random file to sign
        shell: bash
        run: |
          set -euo pipefail
          head -c 4096 /dev/urandom > "$FILE_TO_SIGN"
          echo "‚úÖ Created $FILE_TO_SIGN"
          ls -la "$FILE_TO_SIGN"
          sha256sum "$FILE_TO_SIGN" || true

      - name: Download & install Keyfactor Agent (.deb)
        shell: bash
        env:
          KF_AGENT_DEB_URL: ${{ secrets.KF_AGENT_DEB_URL }}
        run: |
          set -euo pipefail
          AGENT_URL="$(printf "%s" "${KF_AGENT_DEB_URL:-}" | tr -d '\r' | xargs)"
          if [ -z "${AGENT_URL:-}" ]; then
            echo "‚ùå KF_AGENT_DEB_URL is empty"
            exit 1
          fi
          if ! printf "%s" "$AGENT_URL" | grep -qE '^https?://'; then
            echo "‚ùå KF_AGENT_DEB_URL must be ONLY the URL (one line, no quotes)."
            exit 1
          fi

          echo "‚¨áÔ∏è Downloading agent from:"
          echo "$AGENT_URL"
          curl -fsSL -o kf-agent.deb "$AGENT_URL"

          echo "üì¶ Installing agent..."
          sudo dpkg -i kf-agent.deb || (sudo apt-get install -f -y && sudo dpkg -i kf-agent.deb)

          dpkg -l | grep -i keyfactor || true

      - name: Configure agent (keyfactor-setup)
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          set -euo pipefail

          sudo keyfactor-setup \
            hostname="$SIGNUM_HOSTNAME" \
            clientid="$SIGNUM_CLIENTID" \
            username="$SIGNUM_USERNAME" \
            password="$SIGNUM_PASSWORD" \
            loglevel=HIGH logtype=FILE

      - name: Pick free port + write Keyfactor config + restart service
        shell: bash
        run: |
          set -euo pipefail

          PORT=$(comm -23 <(seq 50000 60000 | sort) <(ss -ltn | awk 'NR>1{print $4}' | awk -F: '{print $NF}' | sort -u) | shuf -n 1)
          echo "‚úÖ Using port $PORT"

          echo -e "port=${PORT}\nloglevel=HIGH\nlogtype=FILE" | sudo tee "$KF_CFG_PATH" >/dev/null
          echo "‚úÖ /etc/keyfactor/config:"
          sudo cat "$KF_CFG_PATH"

          sudo systemctl daemon-reload || true
          sudo systemctl enable KeyfactorService || true
          sudo systemctl restart KeyfactorService

      - name: Wait for KeyfactorService to be stable (no restarts)
        shell: bash
        run: |
          set -euo pipefail

          echo "‚è≥ Waiting for KeyfactorService to be stable..."
          STABLE_SECONDS=15
          DEADLINE=$((SECONDS+180))

          while [ $SECONDS -lt $DEADLINE ]; do
            if systemctl is-active --quiet KeyfactorService; then
              OK=1
              for i in $(seq 1 $STABLE_SECONDS); do
                if ! systemctl is-active --quiet KeyfactorService; then
                  OK=0
                  break
                fi
                sleep 1
              done

              if [ "$OK" -eq 1 ]; then
                echo "‚úÖ KeyfactorService stayed active for ${STABLE_SECONDS}s"
                echo "‚úÖ Status:"
                sudo systemctl status KeyfactorService --no-pager || true
                echo "‚úÖ Recent logs:"
                sudo journalctl -u KeyfactorService -n 120 --no-pager || true
                echo "‚úÖ Listening ports:"
                ss -ltnp || true
                exit 0
              fi
            fi

            echo "‚Ä¶service not stable yet; last 30 log lines:"
            sudo journalctl -u KeyfactorService -n 30 --no-pager || true
            sleep 2
          done

          echo "‚ùå KeyfactorService never became stable"
          sudo systemctl status KeyfactorService --no-pager || true
          sudo journalctl -u KeyfactorService -n 300 --no-pager || true
          exit 1

      - name: Resolve PKCS#11 module path
        id: pkcs11
        shell: bash
        run: |
          set -euo pipefail
          FOUND=""

          if [ -f /etc/keyfactor/keyfactor.module ]; then
            FOUND="$(awk -F'"' '/module:/ {print $2; exit}' /etc/keyfactor/keyfactor.module || true)"
          fi

          if [ -z "${FOUND:-}" ]; then
            for p in \
              /usr/local/keyfactor/pkcs11/libkeyfactorpkcs11.so \
              /usr/lib/libkeyfactorpkcs11.so \
              /usr/lib/x86_64-linux-gnu/libkeyfactorpkcs11.so \
              /usr/lib64/libkeyfactorpkcs11.so; do
              if [ -f "$p" ]; then FOUND="$p"; break; fi
            done
          fi

          if [ -z "${FOUND:-}" ]; then
            FOUND="$(sudo find / -type f -name 'libkeyfactorpkcs11.so' 2>/dev/null | head -n 1 || true)"
          fi

          if [ -z "${FOUND:-}" ]; then
            echo "‚ùå libkeyfactorpkcs11.so not found"
            exit 1
          fi

          echo "‚úÖ PKCS#11 module: $FOUND"
          ls -la "$FOUND" || true
          ldd "$FOUND" || true
          echo "module=$FOUND" >> "$GITHUB_OUTPUT"

      - name: Wait for PKCS#11 provider to initialize (C_Initialize must succeed)
        shell: bash
        env:
          MODULE_PATH: ${{ steps.pkcs11.outputs.module }}
        run: |
          set -euo pipefail

          echo "‚è≥ Waiting for PKCS#11 provider to initialize..."
          for i in {1..120}; do
            if pkcs11-tool --module "$MODULE_PATH" --list-slots >/dev/null 2>&1; then
              echo "‚úÖ PKCS#11 initialized"
              pkcs11-tool --module "$MODULE_PATH" --list-slots --verbose || true
              exit 0
            fi
            sleep 1
          done

          echo "‚ùå PKCS#11 did not initialize"
          pkcs11-tool --module "$MODULE_PATH" --list-slots --verbose || true
          sudo journalctl -u KeyfactorService -n 200 --no-pager || true
          exit 1

      - name: List all certs + keys
        shell: bash
        env:
          MODULE_PATH: ${{ steps.pkcs11.outputs.module }}
          USER_PIN: ${{ secrets.USER_PIN }}
        run: |
          set -euo pipefail

          echo "=== CERTS (slot 0) ==="
          pkcs11-tool --module "$MODULE_PATH" --slot 0 --list-objects --type cert || true

          echo "=== PUBKEYS (slot 0) ==="
          pkcs11-tool --module "$MODULE_PATH" --slot 0 --list-objects --type pubkey --verbose || true

          echo "=== PRIVKEYS (slot 0, login) ==="
          pkcs11-tool --module "$MODULE_PATH" --slot 0 --login --pin "$USER_PIN" --list-objects --type privkey --verbose || true

      - name: Choose cert ID + sign (pkcs11-tool)
        shell: bash
        env:
          MODULE_PATH: ${{ steps.pkcs11.outputs.module }}
          USER_PIN: ${{ secrets.USER_PIN }}
          EXPECTED_SUBJECT_FRAGMENT: ${{ env.EXPECTED_SUBJECT_FRAGMENT }}
        run: |
          set -euo pipefail

          CERTS="$(pkcs11-tool --module "$MODULE_PATH" --slot 0 --list-objects --type cert 2>&1)"
          echo "$CERTS"

          MATCH_BLOCK="$(printf "%s\n" "$CERTS" | awk '
            BEGIN{RS="Certificate Object"; ORS=""}
            NR>1{
              block="Certificate Object"$0
              if (ENVIRON["EXPECTED_SUBJECT_FRAGMENT"] != "" && block ~ ENVIRON["EXPECTED_SUBJECT_FRAGMENT"]) { print block; exit }
            }')"

          if [ -n "${MATCH_BLOCK:-}" ]; then
            CERT_ID="$(echo "$MATCH_BLOCK" | awk -F': *' '/^ *ID:/ {print $2; exit}' | tr -d "\r")"
            echo "‚úÖ Found matching cert for subject fragment: $EXPECTED_SUBJECT_FRAGMENT"
          else
            CERT_ID="$(echo "$CERTS" | awk -F': *' '/^ *ID:/ {print $2; exit}' | tr -d "\r")"
            echo "‚ÑπÔ∏è No subject match; using first cert ID"
          fi

          if [ -z "${CERT_ID:-}" ]; then
            echo "‚ùå Could not select a certificate ID"
            exit 1
          fi
          echo "‚úÖ Using cert/key ID: $CERT_ID"

          echo "üîë Ensuring private keys are visible (login)..."
          PRIV="$(pkcs11-tool --module "$MODULE_PATH" --slot 0 --login --pin "$USER_PIN" --list-objects --type privkey 2>&1 || true)"
          echo "$PRIV"

          if ! echo "$PRIV" | grep -qi "Private Key Object"; then
            echo "‚ùå No private keys visible; cannot sign."
            exit 1
          fi

          mkdir -p "$OUT_DIR"
          cp -f "$FILE_TO_SIGN" "$OUT_DIR/"

          MECH="RSA-PKCS"
          echo "‚úçÔ∏è Signing $OUT_DIR/$FILE_TO_SIGN -> $OUT_DIR/$SIG_OUT"
          pkcs11-tool \
            --module "$MODULE_PATH" \
            --slot 0 \
            --login \
            --pin "$USER_PIN" \
            --id "$CERT_ID" \
            --mechanism "$MECH" \
            --sign \
            --input-file "$OUT_DIR/$FILE_TO_SIGN" \
            --output-file "$OUT_DIR/$SIG_OUT"

          echo "‚úÖ Output:"
          ls -la "$OUT_DIR"
          sha256sum "$OUT_DIR/$FILE_TO_SIGN" || true
          sha256sum "$OUT_DIR/$SIG_OUT" || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pkcs11-signed-output
          path: signed-output/*
