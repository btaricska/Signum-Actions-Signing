<#
Sign all files in a folder using SignServer REST API (no auth required).

Environment/Inputs:
  - SIGNSERVER_ENDPOINT  (required) e.g. https://.../workers/PlainSigner/process
  - FILES_DIR (optional, default "filestosign")
  - TIMEOUT_SEC (optional, default 120)

Behavior:
  - For each file in $FilesDir:
      - read bytes -> base64
      - POST JSON: { metaData, filename, data }
      - if JSON.sig / JSON.signature is present (base64) -> decode -> write file.sig
      - if response is raw base64 -> decode -> write file.sig
      - otherwise save response to file.sig (raw) or file.sig.json for debugging
#>

param(
  [string]$FilesDir = $env:FILES_DIR ?? "filestosign",
  [int]$TimeoutSec = [int]($env:TIMEOUT_SEC ?? 120)
)

# required endpoint
$endpoint = $env:SIGNSERVER_ENDPOINT
if ([string]::IsNullOrEmpty($endpoint)) {
  Write-Error "SIGNSERVER_ENDPOINT environment variable is required."
  exit 1
}

Write-Host "Using SignServer endpoint: $endpoint"
Write-Host "Files directory: $FilesDir"

# simple metadata you can extend
$defaultMeta = @{
  additionalProp1 = "value1"
  additionalProp2 = "value2"
  additionalProp3 = "value3"
}

# ensure directory exists
if (-not (Test-Path -Path $FilesDir)) {
  Write-Host "Creating files directory: $FilesDir"
  New-Item -ItemType Directory -Path $FilesDir | Out-Null
}

$files = Get-ChildItem -Path $FilesDir -File -ErrorAction Stop
if ($files.Count -eq 0) {
  Write-Host "No files found in $FilesDir. Nothing to sign."
  exit 0
}

foreach ($f in $files) {
  $inputPath = $f.FullName
  $sigPath = "$($inputPath).sig"
  $sigJsonPath = "$($inputPath).sig.json"
  Write-Host "----"
  Write-Host "Signing file: $inputPath"

  try {
    $bytes = [System.IO.File]::ReadAllBytes($inputPath)
    $b64 = [System.Convert]::ToBase64String($bytes)

    $payload = @{
      metaData = $defaultMeta
      filename = $f.Name
      data     = $b64
    } | ConvertTo-Json -Depth 10

    Write-Host "POST -> $endpoint (timeout ${TimeoutSec}s)..."
    $response = Invoke-RestMethod -Uri $endpoint -Method Post -Headers @{ "Content-Type" = "application/json" } -Body $payload -TimeoutSec $TimeoutSec -ErrorAction Stop

    if ($null -ne $response) {
      # If response is JSON object
      if ($response -is [System.Management.Automation.PSCustomObject]) {
        # common fields: signature, sig, result.signature, etc. Try a few heuristics:
        $sigCandidates = @()
        if ($response.PSObject.Properties.Name -contains 'signature') { $sigCandidates += $response.signature }
        if ($response.PSObject.Properties.Name -contains 'sig')       { $sigCandidates += $response.sig }
        if ($response.PSObject.Properties.Name -contains 'result') {
          try {
            $r = $response.result
            if ($r -is [System.Management.Automation.PSCustomObject] -and $r.PSObject.Properties.Name -contains 'signature') {
              $sigCandidates += $r.signature
            }
          } catch {}
        }

        # write first valid base64 candidate
        $wrote = $false
        foreach ($c in $sigCandidates) {
          if ($null -ne $c -and $c -is [string]) {
            try {
              [System.IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($c))
              Write-Host "Saved signature to $sigPath (decoded from JSON field)"
              $wrote = $true
              break
            } catch {
              Write-Warning "Failed to decode candidate signature: $_"
            }
          }
        }
        if ($wrote) { continue }

        # no signature fields or decode failed -> save JSON response for debugging
        Write-Host "Server returned JSON but no decodable signature field. Saving JSON to $sigJsonPath"
        $response | ConvertTo-Json -Depth 10 | Out-File -FilePath $sigJsonPath -Encoding utf8
        continue
      }

      # If response is raw string (maybe base64)
      $respString = [string]$response
      $isBase64 = $false
      if ($respString.Length -gt 0 -and ($respString.Length % 4 -eq 0) -and ($respString -match '^[A-Za-z0-9\+/]+={0,2}$')) {
        $isBase64 = $true
      }

      if ($isBase64) {
        try {
          [System.IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($respString))
          Write-Host "Saved signature to $sigPath (decoded from raw base64 response)"
          continue
        } catch {
          Write-Warning "Response looked like base64 but decode failed: $_"
        }
      }

      # fallback: save raw string response
      $respString | Out-File -FilePath $sigPath -Encoding utf8
      Write-Host "Saved raw server response to $sigPath"
      continue
    } else {
      Write-Warning "Null response from server for file $inputPath"
    }
  }
  catch {
    Write-Error "Error signing $inputPath : $_"
    if ($_.Exception.Response -ne $null) {
      try {
        $errStream = $_.Exception.Response.GetResponseStream()
        $reader = New-Object System.IO.StreamReader($errStream)
        $errBody = $reader.ReadToEnd()
        Write-Host "Server response: $errBody"
        $errBody | Out-File -FilePath "$sigPath.error" -Encoding utf8
      } catch {
        Write-Warning "Failed to read error response body: $_"
      }
    }
    continue
  }
}

Write-Host "Signing run complete."
