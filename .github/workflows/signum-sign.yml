name: Sign File via Signum Agent (Windows, KSP/CSP)

on:
  workflow_dispatch:
    inputs:
      file_to_sign:
        description: "Path to file to sign (relative to repo root)"
        required: false
        default: "hello-world-app.exe"
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign-windows:
    runs-on: windows-2022

    env:
      OUT_DIR: "signed-output"
      FILE_TO_SIGN: ${{ github.event.inputs.file_to_sign || 'hello-world-app.exe' }}
      EXPECTED_SUBJECT_FRAGMENT: "CN=CodeSigningCertificate"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Runner info
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          Write-Host "Runner OS:"
          cmd /c ver
          Write-Host "PowerShell:"
          $PSVersionTable

      - name: Validate required secrets/vars
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          # IMPORTANT: you said you created a "secret variable" => use vars.*
          KF_AGENT_MSI_URL: ${{ vars.KF_AGENT_MSI_URL }}
          CERT_THUMBPRINT: ${{ secrets.CERT_THUMBPRINT || '' }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"

          $required = @('SIGNUM_HOSTNAME','SIGNUM_CLIENTID','SIGNUM_USERNAME','SIGNUM_PASSWORD','KF_AGENT_MSI_URL')
          $missing = @()
          foreach ($r in $required) {
            $v = (Get-ChildItem env:$r -ErrorAction SilentlyContinue).Value
            if ([string]::IsNullOrWhiteSpace($v)) { $missing += $r }
          }
          if ($missing.Count -gt 0) {
            Write-Error "Missing values: $($missing -join ', '). If KF_AGENT_MSI_URL is an Actions Variable, reference vars.KF_AGENT_MSI_URL."
            exit 1
          }

          $url = $env:KF_AGENT_MSI_URL.Trim()
          if (-not ($url -match '^https?://')) {
            Write-Error "KF_AGENT_MSI_URL must be a plain http(s) URL. Got: '$url'"
            exit 1
          }

          Write-Host "‚úÖ Inputs validated"
          Write-Host "MSI URL: $url"

      - name: Install Keyfactor Agent (MSI)
        shell: pwsh
        env:
          KF_AGENT_MSI_URL: ${{ vars.KF_AGENT_MSI_URL }}
        run: |
          $ErrorActionPreference = "Stop"

          $url = $env:KF_AGENT_MSI_URL.Trim()
          $msi = Join-Path $env:TEMP 'keyfactor-agent.msi'
          $log = Join-Path $env:TEMP 'kf-agent-install.log'

          Write-Host "‚¨áÔ∏è Downloading MSI:"
          Write-Host $url
          Invoke-WebRequest -Uri $url -OutFile $msi -UseBasicParsing
          Write-Host "‚úÖ Downloaded to $msi"
          Get-Item $msi | Format-List Name,Length,LastWriteTime

          Write-Host "üì¶ Installing MSI silently..."
          $p = Start-Process msiexec.exe -Wait -PassThru -ArgumentList "/i `"$msi`" /qn /norestart /l*v `"$log`""
          Write-Host "msiexec exit code: $($p.ExitCode)"

          if ($p.ExitCode -ne 0) {
            Write-Host "---- MSI install log tail ----"
            if (Test-Path $log) { Get-Content $log -Tail 200 }
            throw "MSI install failed with exit code $($p.ExitCode)"
          }

          Write-Host "‚úÖ MSI install complete"

      - name: Configure agent (keyfactor-setup) and start service
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          # Find keyfactor-setup.exe
          $kfCmd = Get-Command keyfactor-setup -ErrorAction SilentlyContinue
          $kf = if ($kfCmd) { $kfCmd.Path } else { $null }

          if (-not $kf) {
            $common = @(
              "C:\Program Files\Keyfactor\Agent\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\Service\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\keyfactor-setup.exe"
            )
            foreach ($p in $common) { if (Test-Path $p) { $kf = $p; break } }
          }

          if (-not $kf) {
            Write-Host "üîé Searching for keyfactor-setup.exe under C:\Program Files ..."
            $found = Get-ChildItem -Path "C:\Program Files" -Filter "keyfactor-setup.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $kf = $found.FullName }
          }

          if (-not $kf) {
            throw "keyfactor-setup.exe not found after MSI install."
          }

          Write-Host "‚úÖ Using keyfactor-setup: $kf"

          & $kf `
            hostname="$env:SIGNUM_HOSTNAME" `
            clientid="$env:SIGNUM_CLIENTID" `
            username="$env:SIGNUM_USERNAME" `
            password="$env:SIGNUM_PASSWORD" `
            loglevel=HIGH logtype=FILE

          # Find Keyfactor service (name varies)
          $svc = Get-Service | Where-Object {
            $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor'
          } | Sort-Object Name | Select-Object -First 1

          if (-not $svc) {
            Write-Host "All services matching Keyfactor:"
            Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Format-Table -AutoSize
            throw "No Keyfactor service found."
          }

          Write-Host "‚úÖ Using service: $($svc.Name) ($($svc.DisplayName))"
          Restart-Service -Name $svc.Name -Force
          Start-Sleep -Seconds 3

          $svc2 = Get-Service -Name $svc.Name
          Write-Host "Service status: $($svc2.Status)"
          if ($svc2.Status -ne 'Running') {
            throw "Service '$($svc2.Name)' is not running after restart."
          }

      - name: Wait for agent service to be stable
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $svc = Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Select-Object -First 1
          if (-not $svc) { throw "Keyfactor service not found." }

          $deadline = (Get-Date).AddMinutes(3)
          while ((Get-Date) -lt $deadline) {
            $s = Get-Service -Name $svc.Name -ErrorAction SilentlyContinue
            if ($s -and $s.Status -eq 'Running') {
              Start-Sleep -Seconds 10
              $s2 = Get-Service -Name $svc.Name -ErrorAction SilentlyContinue
              if ($s2 -and $s2.Status -eq 'Running') {
                Write-Host "‚úÖ Service stable: $($svc.Name)"
                exit 0
              }
            }
            Start-Sleep -Seconds 2
          }

          Write-Error "Service did not become stable in time: $($svc.Name)"
          exit 1

      - name: Verify file to sign exists
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (-not (Test-Path -Path $env:FILE_TO_SIGN)) {
            Write-Error "File to sign not found: $env:FILE_TO_SIGN"
            Write-Host "Workspace listing:"
            Get-ChildItem -Force
            exit 1
          }
          Write-Host "‚úÖ Signing: $env:FILE_TO_SIGN"
          Get-Item $env:FILE_TO_SIGN | Format-List

      - name: Find certificate thumbprint (by secret or subject)
        id: find_cert
        shell: pwsh
        env:
          CERT_THUMBPRINT_SECRET: ${{ secrets.CERT_THUMBPRINT || '' }}
          EXPECTED_SUBJECT_FRAGMENT: ${{ env.EXPECTED_SUBJECT_FRAGMENT }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not [string]::IsNullOrWhiteSpace($env:CERT_THUMBPRINT_SECRET)) {
            $tp = $env:CERT_THUMBPRINT_SECRET.Trim().Replace(' ','').ToUpper()
            Write-Host "‚úÖ Using thumbprint from secret: $tp"
            "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            exit 0
          }

          $frag = $env:EXPECTED_SUBJECT_FRAGMENT
          Write-Host "üîé Searching for certificate subject containing: $frag"

          $found = $null
          foreach ($store in @('LocalMachine','CurrentUser')) {
            $certs = Get-ChildItem -Path "Cert:\$store\My" -ErrorAction SilentlyContinue
            foreach ($c in $certs) {
              if ($c.Subject -like "*$frag*") { $found = $c; break }
            }
            if ($found) { break }
          }

          if (-not $found) {
            Write-Host "‚ö†Ô∏è No matching cert found. Sample subjects:"
            Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            throw "No certificate found matching '$frag'. Set secrets.CERT_THUMBPRINT to force selection."
          }

          $tp = $found.Thumbprint.Replace(' ','').ToUpper()
          Write-Host "‚úÖ Found cert: $($found.Subject)"
          Write-Host "Thumbprint: $tp"
          "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Sign with signtool (preferred) or PowerShell fallback
        shell: pwsh
        env:
          THUMBPRINT: ${{ steps.find_cert.outputs.thumbprint }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"

          $thumb = $env:THUMBPRINT
          if ([string]::IsNullOrWhiteSpace($thumb)) { throw "No thumbprint available." }

          $file = Resolve-Path -Path $env:FILE_TO_SIGN
          $sigtool = Get-Command signtool -ErrorAction SilentlyContinue

          if ($sigtool) {
            Write-Host "‚úçÔ∏è Using signtool"
            & signtool sign /sm /s My /sha1 $thumb /tr $env:TIMESTAMP_URL /td sha256 /fd sha256 $file
            if ($LASTEXITCODE -ne 0) { throw "signtool failed with exit $LASTEXITCODE" }
          } else {
            Write-Host "‚ö†Ô∏è signtool not found; using Set-AuthenticodeSignature"
            $cert = Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Where-Object { $_.Thumbprint -eq $thumb }
            if (-not $cert) { $cert = Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Where-Object { $_.Thumbprint -eq $thumb } }
            if (-not $cert) { throw "Could not load cert by thumbprint from either store." }

            $sig = Set-AuthenticodeSignature -FilePath $file -Certificate $cert -TimestampServer $env:TIMESTAMP_URL
            Write-Host "Signature status: $($sig.Status)"
          }

          $outdir = Join-Path $PWD $env:OUT_DIR
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          Copy-Item -Path $file -Destination (Join-Path $outdir (Split-Path $file -Leaf)) -Force
          Write-Host "‚úÖ Output:"
          Get-ChildItem $outdir | Format-Table

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-output
          path: signed-output/*
