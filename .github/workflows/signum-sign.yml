name: Sign File via Signum Agent (Windows, KSP/CSP)

on:
  workflow_dispatch:
    inputs:
      file_to_sign:
        description: "Path to file to sign (relative to repo root)"
        required: false
        default: "hello-world-app.exe"
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign-windows:
    runs-on: windows-2022

    env:
      OUT_DIR: "signed-output"
      FILE_TO_SIGN: ${{ github.event.inputs.file_to_sign || 'hello-world-app.exe' }}
      EXPECTED_SUBJECT_FRAGMENT: "CN=CodeSigningCertificate"
      DEFAULT_AGENT_MSI_URL: "https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve agent MSI URL (vars -> secrets -> default)
        shell: pwsh
        env:
          MSI_FROM_VARS: ${{ vars.KF_AGENT_MSI_URL || '' }}
          MSI_FROM_SECRETS: ${{ secrets.KF_AGENT_MSI_URL || '' }}
        run: |
          $ErrorActionPreference = "Stop"
          $msi = ($env:MSI_FROM_VARS ?? "").Trim()
          if ([string]::IsNullOrWhiteSpace($msi)) { $msi = ($env:MSI_FROM_SECRETS ?? "").Trim() }
          if ([string]::IsNullOrWhiteSpace($msi)) { $msi = ($env:DEFAULT_AGENT_MSI_URL ?? "").Trim() }

          if (-not ($msi -match '^https?://')) { throw "Resolved MSI URL invalid: '$msi'" }

          "KF_AGENT_MSI_URL=$msi" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "✅ KF_AGENT_MSI_URL resolved to: $msi"

      - name: Validate required Signum secrets
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"
          $required = @('SIGNUM_HOSTNAME','SIGNUM_CLIENTID','SIGNUM_USERNAME','SIGNUM_PASSWORD')
          $missing = @()
          foreach ($r in $required) {
            $v = (Get-ChildItem env:$r -ErrorAction SilentlyContinue).Value
            if ([string]::IsNullOrWhiteSpace($v)) { $missing += $r }
          }
          if ($missing.Count -gt 0) { throw "Missing secrets: $($missing -join ', ')" }
          Write-Host "✅ Signum secrets validated"

      - name: Download MSI
        id: dl
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $url = ($env:KF_AGENT_MSI_URL ?? "").Trim()
          if ([string]::IsNullOrWhiteSpace($url)) { throw "KF_AGENT_MSI_URL is empty" }

          $msi = Join-Path $env:TEMP 'keyfactor-agent.msi'
          $log = Join-Path $env:TEMP 'kf-agent-install.log'

          Invoke-WebRequest -Uri $url -OutFile $msi -UseBasicParsing
          Write-Host "✅ Downloaded MSI to $msi"
          Get-Item $msi | Format-List Name,Length,LastWriteTime

          # Unblock in case Windows marked it as downloaded-from-internet (can break custom actions)
          try { Unblock-File -Path $msi -ErrorAction SilentlyContinue } catch {}

          "MSI_PATH=$msi" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "MSI_LOG=$log"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Install MSI (verbose log + extract real failure)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"

          $msi = $env:MSI_PATH
          $log = $env:MSI_LOG
          if (-not (Test-Path $msi)) { throw "MSI not found at $msi" }

          # Try two common install styles: per-machine ALLUSERS=1, then default
          $attempts = @(
            "/i `"$msi`" ALLUSERS=1 MSIINSTALLPERUSER=0 /qn /norestart /l*v `"$log`"",
            "/i `"$msi`" /qn /norestart /l*v `"$log`""
          )

          $ok = $false
          foreach ($args in $attempts) {
            Write-Host "=== msiexec $args ==="
            if (Test-Path $log) { Remove-Item $log -Force -ErrorAction SilentlyContinue }

            $p = Start-Process msiexec.exe -Wait -PassThru -ArgumentList $args
            Write-Host "msiexec exit code: $($p.ExitCode)"

            if ($p.ExitCode -eq 0) { $ok = $true; break }

            Write-Host "---- MSI log tail ----"
            if (Test-Path $log) { Get-Content $log -Tail 200 }

            # The real failure is usually near "Return value 3"
            Write-Host "---- MSI log failure context (Return value 3) ----"
            if (Test-Path $log) {
              $lines = Get-Content $log
              $idx = ($lines | Select-String -Pattern "Return value 3" | Select-Object -First 1).LineNumber
              if ($idx) {
                $start = [Math]::Max(0, $idx - 60)
                $end   = [Math]::Min($lines.Count-1, $idx + 20)
                $lines[$start..$end] | ForEach-Object { $_ }
              } else {
                Write-Host "(No 'Return value 3' found)"
              }
            }
          }

          if (-not $ok) {
            Write-Host "---- Installed products containing Keyfactor/Redtrust/Evolium ----"
            Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* `
              -ErrorAction SilentlyContinue |
              Where-Object { $_.DisplayName -match 'Keyfactor|Redtrust|Evolium' } |
              Select-Object DisplayName, DisplayVersion, Publisher |
              Format-Table -AutoSize

            Write-Host "---- Services containing Keyfactor ----"
            Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Format-Table -AutoSize

            throw "MSI install failed (see uploaded MSI log artifact)."
          }

          Write-Host "✅ MSI installed successfully"

      - name: Upload MSI install log (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kf-agent-msi-install-log
          path: ${{ env.MSI_LOG }}

      - name: Configure agent (keyfactor-setup) and restart service
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          # Find keyfactor-setup.exe
          $kfCmd = Get-Command keyfactor-setup -ErrorAction SilentlyContinue
          $kf = if ($kfCmd) { $kfCmd.Path } else { $null }

          if (-not $kf) {
            $common = @(
              "C:\Program Files\Keyfactor\Agent\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\Service\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\keyfactor-setup.exe"
            )
            foreach ($p in $common) { if (Test-Path $p) { $kf = $p; break } }
          }

          if (-not $kf) {
            $found = Get-ChildItem -Path "C:\Program Files" -Filter "keyfactor-setup.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $kf = $found.FullName }
          }

          if (-not $kf) { throw "keyfactor-setup.exe not found after MSI install." }
          Write-Host "✅ Using keyfactor-setup: $kf"

          & $kf `
            hostname="$env:SIGNUM_HOSTNAME" `
            clientid="$env:SIGNUM_CLIENTID" `
            username="$env:SIGNUM_USERNAME" `
            password="$env:SIGNUM_PASSWORD" `
            loglevel=HIGH logtype=FILE

          # Restart Keyfactor-ish service (name can vary)
          $svc = Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Sort-Object Name | Select-Object -First 1
          if (-not $svc) { throw "No Keyfactor service found." }

          Restart-Service -Name $svc.Name -Force
          Start-Sleep -Seconds 3
          $svc2 = Get-Service -Name $svc.Name
          Write-Host "Service status: $($svc2.Status)"
          if ($svc2.Status -ne 'Running') { throw "Service not running after restart." }

      - name: Verify file to sign exists
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (-not (Test-Path -Path $env:FILE_TO_SIGN)) {
            Write-Error "File to sign not found: $env:FILE_TO_SIGN"
            Get-ChildItem -Force
            exit 1
          }
          Write-Host "✅ Signing: $env:FILE_TO_SIGN"
          Get-Item $env:FILE_TO_SIGN | Format-List

      - name: Find certificate thumbprint (by secret or subject)
        id: find_cert
        shell: pwsh
        env:
          CERT_THUMBPRINT_SECRET: ${{ secrets.CERT_THUMBPRINT || '' }}
          EXPECTED_SUBJECT_FRAGMENT: ${{ env.EXPECTED_SUBJECT_FRAGMENT }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not [string]::IsNullOrWhiteSpace($env:CERT_THUMBPRINT_SECRET)) {
            $tp = $env:CERT_THUMBPRINT_SECRET.Trim().Replace(' ','').ToUpper()
            "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            Write-Host "✅ Using thumbprint from secret"
            exit 0
          }

          $frag = $env:EXPECTED_SUBJECT_FRAGMENT
          $found = $null
          foreach ($store in @('LocalMachine','CurrentUser')) {
            $certs = Get-ChildItem -Path "Cert:\$store\My" -ErrorAction SilentlyContinue
            foreach ($c in $certs) { if ($c.Subject -like "*$frag*") { $found = $c; break } }
            if ($found) { break }
          }

          if (-not $found) {
            Write-Host "Sample cert subjects:"
            Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            throw "No certificate found matching '$frag'. Set secrets.CERT_THUMBPRINT."
          }

          $tp = $found.Thumbprint.Replace(' ','').ToUpper()
          "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "✅ Found certificate thumbprint."

      - name: Sign with signtool
        shell: pwsh
        env:
          THUMBPRINT: ${{ steps.find_cert.outputs.thumbprint }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"
          $thumb = $env:THUMBPRINT
          if ([string]::IsNullOrWhiteSpace($thumb)) { throw "No thumbprint available." }

          $file = Resolve-Path -Path $env:FILE_TO_SIGN
          $sigtool = Get-Command signtool -ErrorAction SilentlyContinue
          if (-not $sigtool) { throw "signtool not found on runner." }

          & signtool sign /sm /s My /sha1 $thumb /tr $env:TIMESTAMP_URL /td sha256 /fd sha256 $file
          if ($LASTEXITCODE -ne 0) { throw "signtool failed with exit $LASTEXITCODE" }

          $outdir = Join-Path $PWD $env:OUT_DIR
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          Copy-Item -Path $file -Destination (Join-Path $outdir (Split-Path $file -Leaf)) -Force

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-output
          path: signed-output/*
