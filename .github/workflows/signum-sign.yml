# .github/workflows/windows-signing-with-keyfactor-agent.yml
name: Windows Code Signing (Keyfactor Agent)

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: windows-latest

    env:
      OUT_DIR: signed-output
      EXPECTED_SUBJECT_FRAGMENT: CN=CodeSigningCertificate

      # Agent download/install
      MSI_LANGUAGE: en-US

      # Use temp paths created at runtime (GitHub expression context differences can bite)
      # We'll set MSI_PATH/MSI_LOG in a step and export via GITHUB_ENV.
      KF_AGENT_MSI_URL: ${{ secrets.KF_AGENT_MSI_URL }}

      # Keyfactor / Signum connection (store these as secrets)
      SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
      SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
      SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
      SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure PowerShell 7
        shell: pwsh
        run: |
          $PSVersionTable

      - name: Init temp paths + output folder
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          # Use RUNNER_TEMP env var (always present) instead of ${{ runner.temp }} expressions
          $msiPath = Join-Path $env:RUNNER_TEMP "keyfactor-agent.msi"
          $msiLog  = Join-Path $env:RUNNER_TEMP "kf-agent-install.log"

          "MSI_PATH=$msiPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "MSI_LOG=$msiLog"   | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          $outDir = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          Write-Host "MSI_PATH=$msiPath"
          Write-Host "MSI_LOG=$msiLog"
          Write-Host "OUT_DIR=$outDir"

      - name: Create a dummy Windows binary to sign
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $outDir  = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          $cPath   = Join-Path $outDir "hello.c"
          $exePath = Join-Path $outDir "hello-world-app.exe"

          @'
          #include <windows.h>
          int WINAPI WinMain(HINSTANCE h, HINSTANCE p, LPSTR c, int n) { return 0; }
          '@ | Out-File -FilePath $cPath -Encoding ascii

          # Compile into a real PE .exe using MSVC (present on windows-latest)
          $vswhere = Join-Path ${env:ProgramFiles(x86)} "Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) { throw "vswhere.exe not found (unexpected on windows-latest)." }

          $vsInstall = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if ([string]::IsNullOrWhiteSpace($vsInstall) -or -not (Test-Path $vsInstall)) {
            throw "Visual Studio Build Tools with VC tools not found on runner."
          }

          $vcvars = Join-Path $vsInstall "VC\Auxiliary\Build\vcvars64.bat"
          if (-not (Test-Path $vcvars)) { throw "vcvars64.bat not found: $vcvars" }

          Write-Host "Compiling dummy exe: $exePath"
          cmd /c "`"$vcvars`" && cl /nologo /O1 /MT `"$cPath`" /Fe:`"$exePath`""

          if (-not (Test-Path $exePath)) { throw "Failed to create dummy exe: $exePath" }

          "FILE_TO_SIGN=$(Split-Path $exePath -Leaf)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Will sign: $exePath"

      - name: Validate signing input exists
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $path = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          if (-not (Test-Path $path)) {
            throw "File to sign not found: $path"
          }
          Write-Host "Will sign: $path"

      - name: Download Keyfactor Agent MSI
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          if ([string]::IsNullOrWhiteSpace($env:KF_AGENT_MSI_URL)) {
            throw "KF_AGENT_MSI_URL is empty. Set secrets.KF_AGENT_MSI_URL to a direct MSI URL."
          }

          Write-Host "Downloading MSI to: $env:MSI_PATH"
          Invoke-WebRequest -Uri $env:KF_AGENT_MSI_URL -OutFile $env:MSI_PATH -UseBasicParsing

          if (-not (Test-Path $env:MSI_PATH)) { throw "MSI download failed." }
          Write-Host "Downloaded MSI size: $((Get-Item $env:MSI_PATH).Length) bytes"

      - name: Install + Configure Keyfactor Agent (setup)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          function Write-Section([string]$Title) {
            Write-Host ""
            Write-Host "=== $Title ==="
          }

          function Tail-File([string]$Path, [int]$Lines = 200) {
            if (Test-Path $Path) {
              Write-Host "---- Tail($Lines): $Path ----"
              Get-Content -Path $Path -Tail $Lines | ForEach-Object { Write-Host $_ }
            }
          }

          function Assert-Env([string[]]$Names) {
            $missing = @()
            foreach ($n in $Names) {
              $v = (Get-Item -Path "Env:$n" -ErrorAction SilentlyContinue).Value
              if ([string]::IsNullOrWhiteSpace($v)) { $missing += $n }
            }
            if ($missing.Count -gt 0) {
              throw "Missing required env var(s): $($missing -join ', ')"
            }
          }

          function Install-Msi([string]$MsiPath, [string]$LogPath) {
            if (-not (Test-Path $MsiPath)) { throw "MSI not found: $MsiPath" }

            Write-Host "Installing MSI (quiet): $MsiPath"
            $args = @(
              "/i", "`"$MsiPath`"",
              "/qn",
              "/norestart",
              "/l*v", "`"$LogPath`""
            )

            $p = Start-Process -FilePath "msiexec.exe" -ArgumentList $args -Wait -PassThru
            Write-Host "msiexec exit code: $($p.ExitCode)"

            if ($p.ExitCode -ne 0) {
              Tail-File -Path $LogPath -Lines 300
              throw "MSI install failed (exit code $($p.ExitCode))."
            }
          }

          function Find-KeyfactorSetupExe {
            # Prefer uninstall registry InstallLocation(s)
            $uninstallKeys = @(
              "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*",
              "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
            )

            $entries = foreach ($k in $uninstallKeys) {
              Get-ItemProperty -Path $k -ErrorAction SilentlyContinue |
                Where-Object { $_.DisplayName -match 'Keyfactor' -or $_.Publisher -match 'Keyfactor' }
            }

            foreach ($e in $entries) {
              $loc = $e.InstallLocation
              if (-not [string]::IsNullOrWhiteSpace($loc) -and (Test-Path $loc)) {
                $candidate = Join-Path $loc "keyfactor-setup.exe"
                if (Test-Path $candidate) { return $candidate }
              }
            }

            # Fallback: common roots recursive search
            $roots = @(
              $env:ProgramFiles,
              ${env:ProgramFiles(x86)},
              "C:\ProgramData"
            ) | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique

            foreach ($r in $roots) {
              $hit = Get-ChildItem -Path $r -Filter "keyfactor-setup.exe" -Recurse -ErrorAction SilentlyContinue |
                    Select-Object -First 1
              if ($hit) { return $hit.FullName }
            }

            return $null
          }

          function Run-KeyfactorSetup([string]$SetupExe) {
            Assert-Env @("SIGNUM_HOSTNAME","SIGNUM_CLIENTID","SIGNUM_USERNAME","SIGNUM_PASSWORD")

            Write-Host "✅ Using keyfactor-setup: $SetupExe"
            & $SetupExe `
              hostname="$env:SIGNUM_HOSTNAME" `
              clientid="$env:SIGNUM_CLIENTID" `
              username="$env:SIGNUM_USERNAME" `
              password="$env:SIGNUM_PASSWORD" `
              loglevel=HIGH logtype=FILE
          }

          function Restart-FirstKeyfactorService {
            $svc = Get-Service |
              Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } |
              Sort-Object Name |
              Select-Object -First 1

            if (-not $svc) { throw "No Keyfactor service found." }

            Write-Host "Restarting service: $($svc.Name) ($($svc.DisplayName))"
            Restart-Service -Name $svc.Name -Force
            Start-Sleep -Seconds 3

            $svc2 = Get-Service -Name $svc.Name
            Write-Host "Service $($svc2.Name) status: $($svc2.Status)"
            if ($svc2.Status -ne 'Running') { throw "Service not running after restart." }
          }

          Write-Section "Install Agent MSI"
          Install-Msi -MsiPath $env:MSI_PATH -LogPath $env:MSI_LOG

          Write-Section "Locate keyfactor-setup.exe"
          $kf = Find-KeyfactorSetupExe
          if (-not $kf) {
            Write-Host "keyfactor-setup.exe not found."
            Write-Host "MSI log hints (INSTALLDIR/TARGETDIR):"
            if (Test-Path $env:MSI_LOG) {
              Select-String -Path $env:MSI_LOG -Pattern "INSTALLDIR","TARGETDIR","InstallLocation" -ErrorAction SilentlyContinue |
                Select-Object -First 200 | ForEach-Object { Write-Host $_.Line }
            }
            throw "keyfactor-setup.exe not found after MSI install."
          }

          Write-Section "Run keyfactor-setup"
          Run-KeyfactorSetup -SetupExe $kf

          Write-Section "Restart Keyfactor service"
          Restart-FirstKeyfactorService

          Write-Section "Agent ready"
          Write-Host "✅ Agent installed, configured, and service restarted."

      - name: Ensure signtool is available
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          if (Get-Command signtool.exe -ErrorAction SilentlyContinue) {
            Write-Host "signtool.exe found on PATH."
            exit 0
          }

          # Try to locate signtool in the Windows SDK that is typically installed on windows-latest
          $kits = @(
            "${env:ProgramFiles(x86)}\Windows Kits\10\bin",
            "${env:ProgramFiles(x86)}\Windows Kits\11\bin"
          ) | Where-Object { Test-Path $_ }

          foreach ($k in $kits) {
            $hit = Get-ChildItem -Path $k -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($hit) {
              Write-Host "Found signtool at: $($hit.FullName)"
              $dir = Split-Path $hit.FullName -Parent
              Add-Content -Path $env:GITHUB_PATH -Value $dir
              Write-Host "Added to PATH: $dir"
              exit 0
            }
          }

          throw "signtool.exe not found. Install Windows SDK or use your agent-specific signing CLI."

      - name: Sign file
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $inPath = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          if (-not (Test-Path $inPath)) { throw "Input not found: $inPath" }

          Write-Host "Signing: $inPath"
          & signtool.exe sign /fd sha256 /tr http://timestamp.digicert.com /td sha256 "$inPath"

      - name: Verify signature subject
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $signed = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          if (-not (Test-Path $signed)) { throw "Signed file not found: $signed" }

          $sig = Get-AuthenticodeSignature -FilePath $signed
          Write-Host "Signature status: $($sig.Status)"
          if ($sig.SignerCertificate) {
            Write-Host "Signer subject: $($sig.SignerCertificate.Subject)"
          }

          if ($sig.Status -ne "Valid") { throw "Signature is not valid: $($sig.Status)" }

          $subject = $sig.SignerCertificate.Subject
          if ($subject -notlike "*$($env:EXPECTED_SUBJECT_FRAGMENT)*") {
            throw "Signer subject does not contain expected fragment: '$($env:EXPECTED_SUBJECT_FRAGMENT)'. Actual: '$subject'"
          }

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-output
          path: ${{ env.OUT_DIR }}
          if-no-files-found: error
