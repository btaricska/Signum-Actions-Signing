name: Sign JSON via SignServer (bypass TLS validation for testing)

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  sign:
    runs-on: ubuntu-latest

    env:
      SIGNSERVER_ENDPOINT: "https://signserverdemo.eastus2.cloudapp.azure.com/signserver/rest/v1/workers/PlainSigner/process"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create JSON and Sign via SignServer (bypass TLS validation - TEST ONLY)
        shell: pwsh
        run: |
          Write-Host "Using endpoint: $env:SIGNSERVER_ENDPOINT"

          # Create folder
          $dir = "filestosign"
          if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir | Out-Null
          }

          # Create small JSON file
          $jsonContent = @{
            message = "Hello from GitHub Actions"
            timestamp = (Get-Date -Format u)
          }

          $filePath = Join-Path $dir "file.json"
          $jsonContent | ConvertTo-Json -Depth 5 | Set-Content -Path $filePath -Encoding utf8
          Write-Host "Created JSON file: $filePath"

          # Read file content as raw text
          $fileText = Get-Content -Path $filePath -Raw -Encoding utf8

          # Build payload
          $requestPayload = @{
            metaData = @{
              additionalProp1 = "value1"
              additionalProp2 = "value2"
              additionalProp3 = "value3"
            }
            data = $fileText
          } | ConvertTo-Json -Depth 10

          $sigPath = "$filePath.sig"
          $respSaved = "$filePath.response.json"

          # --- Temporarily bypass TLS certificate validation (TEST ONLY) ---
          # Save existing callback so we can restore it later
          $oldCallback = [System.Net.ServicePointManager]::ServerCertificateValidationCallback

          # Set callback to always accept certificate
          [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { param($sender,$cert,$chain,$errors) return $true }

          try {
            Write-Host "Sending request to SignServer (certificate validation bypassed)..."
            $response = Invoke-RestMethod `
              -Uri $env:SIGNSERVER_ENDPOINT `
              -Method Post `
              -Headers @{ 'Content-Type' = 'application/json' } `
              -Body $requestPayload `
              -TimeoutSec 120 `
              -ErrorAction Stop

            Write-Host "Request successful. Saving full response for debug: $respSaved"
            if ($null -ne $response) {
              $response | ConvertTo-Json -Depth 10 | Out-File -FilePath $respSaved -Encoding utf8
            } else {
              "null" | Out-File -FilePath $respSaved -Encoding utf8
            }

            # Try to extract signature (common locations)
            $wrote = $false
            if ($response -is [PSCustomObject]) {
              if ($response.PSObject.Properties.Name -contains "signature") {
                $sigValue = $response.signature
                if ($sigValue -match '^[A-Za-z0-9+/=]+$') {
                  [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($sigValue))
                  Write-Host "Saved decoded signature to $sigPath"
                  $wrote = $true
                } else {
                  $sigValue | Out-File -FilePath $sigPath -Encoding utf8
                  Write-Host "Saved raw signature text to $sigPath"
                  $wrote = $true
                }
              } elseif ($response.PSObject.Properties.Name -contains "sig") {
                $sigValue = $response.sig
                if ($sigValue -match '^[A-Za-z0-9+/=]+$') {
                  [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($sigValue))
                  Write-Host "Saved decoded signature to $sigPath"
                  $wrote = $true
                } else {
                  $sigValue | Out-File -FilePath $sigPath -Encoding utf8
                  Write-Host "Saved raw signature text to $sigPath"
                  $wrote = $true
                }
              }
            }

            if (-not $wrote) {
              # If response was raw (maybe base64)
              $respString = [string]$response
              if ($respString -and ($respString -match '^[A-Za-z0-9+/=]+$')) {
                try {
                  [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($respString))
                  Write-Host "Saved decoded signature to $sigPath (raw response)"
                  $wrote = $true
                } catch {
                  Write-Warning "Raw response looked like base64 but decode failed: $_"
                }
              }
            }

            if (-not $wrote) {
              Write-Warning "Signature not auto-extracted. Inspect $respSaved for response details. Saving raw response to $sigPath."
              $response | Out-File -FilePath $sigPath -Encoding utf8
            }

          } catch {
            Write-Error "Error occurred during REST call: $_"
            if ($_.Exception.Response -ne $null) {
              try {
                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                $errorDetails = $reader.ReadToEnd()
                Write-Host "Server Response: $errorDetails"
                $errorDetails | Out-File -FilePath "$filePath.sig.error" -Encoding utf8
              } catch {
                Write-Warning "Unable to read response body: $_"
              }
            }
            throw
          } finally {
            # Restore previous certificate validation callback
            [System.Net.ServicePointManager]::ServerCertificateValidationCallback = $oldCallback
            Write-Host "Restored previous certificate validation callback."
          }

      - name: Upload signature artifact
        uses: actions/upload-artifact@v4
        with:
          name: signature
          path: filestosign/file.json.sig
