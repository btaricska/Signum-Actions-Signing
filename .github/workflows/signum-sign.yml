# .github/workflows/windows-signing-with-keyfactor-agent.yml
name: Windows Code Signing (Keyfactor Agent)

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

permissions:
  contents: read

jobs:
  sign:
    runs-on: windows-latest

    env:
      OUT_DIR: signed-output
      FILE_TO_SIGN: file-to-sign.bin

      # MSI download/install
      KF_AGENT_MSI_URL: https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi
      MSI_PATH: ${{ github.workspace }}\kf-agent.msi
      MSI_LOG:  ${{ github.workspace }}\kf-agent-install.log
      MSI_LANGUAGE: en-US

      # Signum connection (secrets)
      SIGNUM_HOSTNAME:  ${{ secrets.SIGNUM_HOSTNAME }}
      SIGNUM_CLIENTID:  ${{ secrets.SIGNUM_CLIENTID }}
      SIGNUM_USERNAME:  ${{ secrets.SIGNUM_USERNAME }}
      SIGNUM_PASSWORD:  ${{ secrets.SIGNUM_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare output + create a random file to sign
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          New-Item -ItemType Directory -Force -Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) | Out-Null
          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN

          # Create a random binary file (so we don't care what we're signing)
          $bytes = New-Object byte[] 2048
          (New-Object System.Random).NextBytes($bytes)
          [System.IO.File]::WriteAllBytes($file, $bytes)

          Write-Host "Created file to sign: $file"
          Get-Item $file | Format-List FullName,Length,LastWriteTime

      - name: Download Keyfactor Agent MSI (curl)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          Write-Host "Downloading MSI to: $env:MSI_PATH"
          curl.exe -L -o "$env:MSI_PATH" "$env:KF_AGENT_MSI_URL"

          if (-not (Test-Path $env:MSI_PATH)) { throw "MSI download failed: $env:MSI_PATH" }
          Write-Host "Downloaded MSI size: $((Get-Item $env:MSI_PATH).Length) bytes"

      - name: Install Keyfactor Agent MSI (pass required properties)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          function Tail-File([string]$Path, [int]$Lines = 300) {
            if (Test-Path $Path) {
              Write-Host "---- Tail($Lines): $Path ----"
              Get-Content -Path $Path -Tail $Lines | ForEach-Object { Write-Host $_ }
            }
          }

          foreach ($n in @("SIGNUM_HOSTNAME","SIGNUM_CLIENTID")) {
            if ([string]::IsNullOrWhiteSpace((Get-Item "Env:$n" -ErrorAction SilentlyContinue).Value)) {
              throw "Missing required env var: $n"
            }
          }

          $rtPrimary = $env:SIGNUM_HOSTNAME
          $clientId  = $env:SIGNUM_CLIENTID
          $lang      = if ([string]::IsNullOrWhiteSpace($env:MSI_LANGUAGE)) { "en-US" } else { $env:MSI_LANGUAGE }

          Write-Host "Installing MSI: $env:MSI_PATH"
          Write-Host "  RTPRIMARY=$rtPrimary"
          Write-Host "  CLIENTID=$clientId"
          Write-Host "  LANGUAGE=$lang"
          Write-Host "  Log=$env:MSI_LOG"

          $args = @(
            "/i", "`"$env:MSI_PATH`"",
            "RTPRIMARY=`"$rtPrimary`"",
            "CLIENTID=`"$clientId`"",
            "LANGUAGE=`"$lang`"",
            "/qn",
            "/norestart",
            "/l*v", "`"$env:MSI_LOG`""
          )

          $p = Start-Process -FilePath "msiexec.exe" -ArgumentList $args -Wait -PassThru
          Write-Host "msiexec exit code: $($p.ExitCode)"

          if ($p.ExitCode -ne 0) {
            Tail-File -Path $env:MSI_LOG -Lines 400
            throw "MSI install failed (exit code $($p.ExitCode))."
          }

          Write-Host "✅ MSI installed."

      - name: Locate Keyfactor install + show tools (no auto-run)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $dir = "C:\Program Files\KeyFactor"
          if (Test-Path $dir) {
            Write-Host "KeyFactor install dir: $dir"
            Get-ChildItem $dir -File -ErrorAction SilentlyContinue |
              Sort-Object Name |
              Select-Object Name,FullName,Length,LastWriteTime |
              Format-Table -AutoSize
          } else {
            Write-Host "KeyFactor install dir not found at: $dir"
          }

      - name: Restart Keyfactor-ish services (ignore access denied)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $svcs = Get-CimInstance Win32_Service |
            Where-Object { $_.Name -match 'keyfactor|signum|redtrust|rtksp' -or $_.DisplayName -match 'keyfactor|signum|redtrust|rtksp' } |
            Sort-Object Name

          if (-not $svcs -or $svcs.Count -eq 0) {
            Write-Host "No Keyfactor-ish services found to restart."
            exit 0
          }

          foreach ($s in $svcs) {
            try {
              Write-Host "Restarting service: $($s.Name) ($($s.DisplayName))"
              Restart-Service -Name $s.Name -Force -ErrorAction Stop
              Start-Sleep -Seconds 2
              $st = (Get-Service -Name $s.Name -ErrorAction SilentlyContinue).Status
              Write-Host "  Status: $st"
            } catch {
              Write-Host "Skipping service (could not restart): $($s.Name) :: $($_.Exception.Message)"
            }
          }

      - name: Dump certificates + attempt signing (any cert)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          function Find-SignTool {
            $cmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
            if ($cmd) { return $cmd.Source }

            $roots = @(
              "C:\Program Files (x86)\Windows Kits\10\bin",
              "C:\Program Files (x86)\Windows Kits\8.1\bin"
            ) | Where-Object { Test-Path $_ }

            foreach ($r in $roots) {
              $hits = Get-ChildItem -Path $r -Filter signtool.exe -Recurse -ErrorAction SilentlyContinue
              if ($hits) {
                return ($hits.FullName |
                  Sort-Object @{ Expression = { $_ -match '\\x64\\' }; Descending = $true },
                              @{ Expression = { $_ }; Descending = $true } |
                  Select-Object -First 1)
              }
            }
            return $null
          }

          function Dump-Certs {
            Write-Host ""
            Write-Host "=== Certificate inventory (PowerShell) ==="
            $stores = @("My","TrustedPeople","Root","CA")
            $locs   = @("CurrentUser","LocalMachine")

            foreach ($loc in $locs) {
              foreach ($store in $stores) {
                $path = "Cert:\$loc\$store"
                if (Test-Path $path) {
                  $certs = Get-ChildItem $path -ErrorAction SilentlyContinue
                  Write-Host ""
                  Write-Host "--- $path ($($certs.Count)) ---"
                  $certs |
                    Select-Object Subject, Issuer, Thumbprint, NotAfter, HasPrivateKey |
                    Format-Table -AutoSize
                }
              }
            }

            Write-Host ""
            Write-Host "=== Certificate inventory (certutil, truncated) ==="
            foreach ($loc in @("user","machine")) {
              foreach ($store in @("My","TrustedPeople","Root","CA")) {
                Write-Host ""
                Write-Host "--- certutil -store $loc $store ---"
                & certutil.exe -store $loc $store 2>&1 |
                  Select-Object -First 120 |
                  ForEach-Object { Write-Host $_ }
              }
            }
          }

          $signtool = Find-SignTool
          if (-not $signtool) { throw "signtool.exe not found." }
          Write-Host "Using signtool: $signtool"

          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          if (-not (Test-Path $file)) { throw "File not found to sign: $file" }
          Write-Host "Signing: $file"

          Dump-Certs

          Write-Host ""
          Write-Host "=== Attempt 1: signtool /a (auto-select) ==="
          $p = Start-Process -FilePath $signtool -ArgumentList @(
            "sign",
            "/a",
            "/fd","sha256",
            "/tr","http://timestamp.digicert.com",
            "/td","sha256",
            "$file"
          ) -Wait -PassThru -NoNewWindow

          if ($p.ExitCode -eq 0) {
            Write-Host "✅ Signed successfully with /a"
            exit 0
          }

          Write-Host "Attempt 1 failed (exit $($p.ExitCode))."

          Write-Host ""
          Write-Host "=== Attempt 2: pick first cert with private key ==="
          $candidates = @()
          foreach ($loc in @("CurrentUser","LocalMachine")) {
            foreach ($store in @("My","TrustedPeople")) {
              $path = "Cert:\$loc\$store"
              if (Test-Path $path) {
                $candidates += Get-ChildItem $path -ErrorAction SilentlyContinue
              }
            }
          }

          $withKey = $candidates | Where-Object { $_.HasPrivateKey } | Sort-Object NotAfter -Descending
          if (-not $withKey -or $withKey.Count -eq 0) {
            Write-Host "❌ No certs with private keys found in searched stores."
            Write-Host ""
            Write-Host "=== KeyFactor install dir listing (truncated) ==="
            if (Test-Path "C:\Program Files\KeyFactor") {
              Get-ChildItem "C:\Program Files\KeyFactor" -Recurse -ErrorAction SilentlyContinue |
                Select-Object FullName,Length,LastWriteTime |
                Select-Object -First 200 |
                Format-Table -AutoSize
            } else {
              Write-Host "C:\Program Files\KeyFactor not found."
            }
            throw "No certificates available for signing on the runner."
          }

          $chosen = $withKey | Select-Object -First 1
          $thumb  = ($chosen.Thumbprint -replace '\s','')
          Write-Host "Using cert:"
          Write-Host "  Subject: $($chosen.Subject)"
          Write-Host "  Thumb:   $thumb"
          Write-Host "  Expires: $($chosen.NotAfter)"

          $p2 = Start-Process -FilePath $signtool -ArgumentList @(
            "sign",
            "/sha1",$thumb,
            "/fd","sha256",
            "/tr","http://timestamp.digicert.com",
            "/td","sha256",
            "$file"
          ) -Wait -PassThru -NoNewWindow

          if ($p2.ExitCode -ne 0) {
            throw "Signing failed (exit $($p2.ExitCode)). Cert exists but key may be inaccessible or provider not active."
          }

          Write-Host "✅ Signed successfully with thumbprint."

      - name: Verify signature (best-effort)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          $sig = Get-AuthenticodeSignature -FilePath $file
          Write-Host "Signature status: $($sig.Status)"
          if ($sig.SignerCertificate) {
            Write-Host "Signer subject: $($sig.SignerCertificate.Subject)"
            Write-Host "Thumbprint: $($sig.SignerCertificate.Thumbprint)"
          }

      - name: Upload signed artifact folder
        uses: actions/upload-artifact@v4
        with:
          name: signed-output
          path: ${{ env.OUT_DIR }}
          if-no-files-found: error
