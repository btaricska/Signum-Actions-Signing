name: "Keyfactor Signum Jar Signing (JFrog)"

on:
  workflow_dispatch:
    inputs:
      jar_path:
        description: "Optional path to a specific JAR to sign (e.g., apps/hello/app_unsigned.jar)"
        required: false
        type: string
  push:
    tags: ["v*.*.*"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: ubuntu-latest

    env:
      SIGNUM_AGENT_IMAGE: keyfactor.jfrog.io/signum-bdewberry-testing-docker/signum-linux-agent-tools:4.40.1
      CONTAINER_NAME: signum-agent
      DOCKER_CONFIG: ${{ github.workspace }}/.docker

      PKCS11_CFG: /etc/keyfactor/keyfactorpkcs11.cfg
      SIGNED_DIR: out/signed

      # Optional: set as a GitHub Actions Variable (not secret)
      SIGNUM_CERT_ALIAS: ${{ vars.SIGNUM_CERT_ALIAS }}
      # Optional TSA (variable); if set, we’ll use it
      SIGNUM_TSA_URL: ${{ vars.SIGNUM_TSA_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Validate secrets
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          JFROG_DOCKER_AUTH: ${{ secrets.JFROG_DOCKER_AUTH }}
        run: |
          set -euo pipefail
          for s in SIGNUM_HOSTNAME SIGNUM_CLIENTID SIGNUM_USERNAME SIGNUM_PASSWORD JFROG_DOCKER_AUTH; do
            if [ -z "${!s:-}" ]; then
              echo "❌ Missing secret: $s"
              exit 1
            fi
          done
          echo "✅ Secrets validated"

      - name: Configure Docker auth (JFrog)
        shell: bash
        env:
          JFROG_DOCKER_AUTH: ${{ secrets.JFROG_DOCKER_AUTH }}
        run: |
          set -euo pipefail
          mkdir -p "$DOCKER_CONFIG"
          cat > "$DOCKER_CONFIG/config.json" <<'EOF'
          {
            "auths": {
              "keyfactor.jfrog.io": {
                "auth": "__AUTH__"
              }
            }
          }
          EOF
          sed -i "s|__AUTH__|${JFROG_DOCKER_AUTH}|g" "$DOCKER_CONFIG/config.json"
          echo "✅ Wrote Docker auth to $DOCKER_CONFIG/config.json"
          cat "$DOCKER_CONFIG/config.json" | sed 's/"auth":[[:space:]]*".*"/"auth":"***"/'

      - name: Ensure a JAR exists to sign (use input, existing demo, or build demo)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out

          # Use workflow input if provided
          if [ -n "${{ inputs.jar_path }}" ]; then
            test -f "${{ inputs.jar_path }}" || { echo "❌ jar_path not found: ${{ inputs.jar_path }}"; exit 1; }
            printf '%s\n' "${{ inputs.jar_path }}" > out/jars.txt
            echo "✅ Using jar_path input:"
            cat out/jars.txt
            exit 0
          fi

          # Prefer the canonical demo jar path from your doc
          if [ -f "apps/hello/app_unsigned.jar" ]; then
            echo "apps/hello/app_unsigned.jar" > out/jars.txt
            echo "✅ Found apps/hello/app_unsigned.jar"
            exit 0
          fi

          # If Hello.java exists, build demo jar on the runner (simple + reliable)
          if [ -f "apps/hello/Hello.java" ]; then
            echo "⚙️ No JAR found; building apps/hello/app_unsigned.jar from Hello.java"
            mkdir -p apps/hello/build
            javac -d apps/hello/build apps/hello/Hello.java
            jar --create --file apps/hello/app_unsigned.jar -C apps/hello/build .
            echo "apps/hello/app_unsigned.jar" > out/jars.txt
            ls -la apps/hello/app_unsigned.jar
            echo "✅ Built demo jar and staged jars list:"
            cat out/jars.txt
            exit 0
          fi

          echo "❌ No JAR found and no apps/hello/Hello.java to build one."
          echo "➡️ Add a JAR to the repo or add apps/hello/Hello.java."
          exit 1

      - name: Start Signum Agent container (JFrog image)
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          set -euo pipefail

          docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
          docker pull "$SIGNUM_AGENT_IMAGE"

          docker run -d \
            --name "$CONTAINER_NAME" \
            --privileged \
            --user 0:0 \
            -e SIGNUM_HOSTNAME \
            -e SIGNUM_CLIENTID \
            -e SIGNUM_USERNAME \
            -e SIGNUM_PASSWORD \
            -e SIGNUM_LOGLEVEL=HIGH \
            -e SIGNUM_LOGTYPE=FILE \
            -v "$PWD:/work" \
            "$SIGNUM_AGENT_IMAGE"

          echo "⏳ Waiting for container to stay up..."
          for i in {1..30}; do
            if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              echo "❌ Container exited early. Logs:"
              docker logs "$CONTAINER_NAME" | tail -n 300 || true
              exit 1
            fi
            sleep 1
          done
          echo "✅ Container is running"

      - name: Configure agent + start service inside container
        shell: bash
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          set -euo pipefail

          docker exec "$CONTAINER_NAME" sh -lc "install -d /etc/keyfactor"

          docker exec "$CONTAINER_NAME" sh -lc "cat > '$PKCS11_CFG' <<'EOF'
          name = KeyfactorPKCS11
          library = /usr/lib/libkeyfactorpkcs11.so
          description = \"Keyfactor PKCS#11 interface\"
          EOF"

          docker exec "$CONTAINER_NAME" sh -lc "ls -la '$PKCS11_CFG' && test -f /usr/lib/libkeyfactorpkcs11.so"

          docker exec "$CONTAINER_NAME" sh -lc "
            set -euo pipefail
            keyfactor-setup \
              hostname=\"$SIGNUM_HOSTNAME\" \
              clientid=\"$SIGNUM_CLIENTID\" \
              username=\"$SIGNUM_USERNAME\" \
              password=\"$SIGNUM_PASSWORD\" \
              loglevel=HIGH \
              logtype=FILE
          "

          docker exec "$CONTAINER_NAME" sh -lc '
            set -euo pipefail
            SVC_DIR=/usr/local/keyfactor/service
            LOG=/var/log/KeyfactorService.log
            if [ -x "$SVC_DIR/KeyfactorService" ]; then
              "$SVC_DIR/KeyfactorService" >>"$LOG" 2>&1 &
            else
              dotnet "$SVC_DIR/KeyfactorService.dll" >>"$LOG" 2>&1 &
            fi
            for i in $(seq 1 120); do
              (exec 3<>/dev/tcp/127.0.0.1/51599) >/dev/null 2>&1 && { echo "agent listening"; exit 0; }
              sleep 1
            done
            echo "Agent did not open 127.0.0.1:51599 in time"
            tail -n 200 "$LOG" || true
            exit 1
          '

          docker exec "$CONTAINER_NAME" sh -lc 'keyfactor-setup test || (tail -n 200 /var/log/KeyfactorService.log; exit 1)'

      - name: Discover PrivateKeyEntry alias (keytool in container)
        shell: bash
        run: |
          set -euo pipefail

          docker exec "$CONTAINER_NAME" sh -lc "
            set -euo pipefail
            cd /work
            mkdir -p out
            keytool -J--add-modules=jdk.crypto.cryptoki \
              -list -v -keystore NONE \
              -storetype PKCS11 -storepass NONE \
              -providerClass sun.security.pkcs11.SunPKCS11 \
              -providerArg '$PKCS11_CFG' > out/pkcs11-list.txt

            awk '
              BEGIN{ alias=\"\"; type=\"\" }
              /^Alias name: /{ alias=\$0; sub(/^Alias name: /,\"\",alias) }
              /^Entry type: /{
                type=\$0; sub(/^Entry type: /,\"\",type);
                if (type==\"PrivateKeyEntry\") { print alias }
              }' out/pkcs11-list.txt > out/private_aliases.txt

            test -s out/private_aliases.txt
            echo \"✅ PrivateKeyEntry aliases:\"
            nl -ba out/private_aliases.txt
          "

          HINT="${SIGNUM_CERT_ALIAS:-}"
          if [ -n "$HINT" ] && grep -Fxq "$HINT" out/private_aliases.txt; then
            echo "SIGNING_ALIAS=$HINT" >> "$GITHUB_ENV"
            echo "✅ Using provided SIGNUM_CERT_ALIAS"
          else
            CHOSEN="$(head -n 1 out/private_aliases.txt)"
            echo "SIGNING_ALIAS=$CHOSEN" >> "$GITHUB_ENV"
            echo "✅ Using discovered alias: $CHOSEN"
          fi

      - name: Sign JAR(s) with jarsigner + verify
        shell: bash
        run: |
          set -euo pipefail
          : "${SIGNING_ALIAS:?Missing SIGNING_ALIAS}"

          docker exec "$CONTAINER_NAME" sh -lc "
            set -euo pipefail
            cd /work
            mkdir -p '$SIGNED_DIR'
            > '$SIGNED_DIR/manifest.txt'
            > '$SIGNED_DIR/SHA256SUMS.txt'

            while IFS= read -r SRC; do
              [ -f \"\$SRC\" ] || { echo \"Skipping missing: \$SRC\"; continue; }

              REL=\${SRC#./}
              REL_DIR=\$(dirname \"\$REL\")
              BASE=\$(basename \"\$SRC\" .jar)
              DEST_DIR='$SIGNED_DIR'/\"\$REL_DIR\"
              mkdir -p \"\$DEST_DIR\"
              DEST=\"\$DEST_DIR/\${BASE}-signed.jar\"

              echo \"→ Signing \$SRC as '$SIGNING_ALIAS'\"
              jarsigner -J--add-modules=jdk.crypto.cryptoki \
                -keystore NONE \
                -storetype PKCS11 -storepass NONE \
                -providerClass sun.security.pkcs11.SunPKCS11 \
                -providerArg '$PKCS11_CFG' \
                ${SIGNUM_TSA_URL:+-tsa \"$SIGNUM_TSA_URL\"} \
                -signedjar \"\$DEST\" \"\$SRC\" '$SIGNING_ALIAS'

              echo \"→ Verifying \$DEST\"
              jarsigner -J--add-modules=jdk.crypto.cryptoki -verify -verbose -certs \"\$DEST\"

              sha256sum \"\$DEST\" >> '$SIGNED_DIR/SHA256SUMS.txt'
              echo \"\$SRC -> \$DEST\" >> '$SIGNED_DIR/manifest.txt'
            done < out/jars.txt
          "

      - name: Upload signed jars + diagnostics
        uses: actions/upload-artifact@v4
        with:
          name: signed-jars
          path: |
            out/jars.txt
            out/pkcs11-list.txt
            out/private_aliases.txt
            out/signed/**

      - name: Cleanup container
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          docker logs "$CONTAINER_NAME" | tail -n 300 || true
          docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
