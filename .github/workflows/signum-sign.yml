name: Sign File via Signum Agent (Windows, KSP/CSP)

on:
  workflow_dispatch:
    inputs:
      file_to_sign:
        description: "Path to file to sign (relative to repo root)"
        required: false
        default: "hello-world-app.exe"
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign-windows:
    runs-on: windows-2022

    env:
      OUT_DIR: "signed-output"
      FILE_TO_SIGN: ${{ github.event.inputs.file_to_sign || 'hello-world-app.exe' }}
      EXPECTED_SUBJECT_FRAGMENT: "CN=CodeSigningCertificate"
      DEFAULT_AGENT_MSI_URL: "https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve agent MSI URL (vars -> secrets -> default)
        id: resolve_msi
        shell: pwsh
        env:
          MSI_FROM_VARS: ${{ vars.KF_AGENT_MSI_URL || '' }}
          MSI_FROM_SECRETS: ${{ secrets.KF_AGENT_MSI_URL || '' }}
          DEFAULT_AGENT_MSI_URL: ${{ env.DEFAULT_AGENT_MSI_URL }}
        run: |
          $ErrorActionPreference = "Stop"

          $msi = ($env:MSI_FROM_VARS ?? "").Trim()
          if ([string]::IsNullOrWhiteSpace($msi)) {
            $msi = ($env:MSI_FROM_SECRETS ?? "").Trim()
          }
          if ([string]::IsNullOrWhiteSpace($msi)) {
            $msi = ($env:DEFAULT_AGENT_MSI_URL ?? "").Trim()
            Write-Host "‚úÖ Using DEFAULT_AGENT_MSI_URL from workflow"
          } else {
            Write-Host "‚úÖ Using KF_AGENT_MSI_URL from vars/secrets"
          }

          if (-not ($msi -match '^https?://')) {
            throw "Resolved MSI URL is invalid: '$msi'"
          }

          "KF_AGENT_MSI_URL=$msi" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "msi_url=$msi" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "MSI URL resolved."

      - name: Validate required Signum secrets
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
          CERT_THUMBPRINT: ${{ secrets.CERT_THUMBPRINT || '' }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"
          $required = @('SIGNUM_HOSTNAME','SIGNUM_CLIENTID','SIGNUM_USERNAME','SIGNUM_PASSWORD')
          $missing = @()
          foreach ($r in $required) {
            $v = (Get-ChildItem env:$r -ErrorAction SilentlyContinue).Value
            if ([string]::IsNullOrWhiteSpace($v)) { $missing += $r }
          }
          if ($missing.Count -gt 0) {
            throw "Missing secrets: $($missing -join ', ')"
          }
          Write-Host "‚úÖ Signum secrets validated"

      - name: Install Keyfactor Agent (MSI)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $url = ($env:KF_AGENT_MSI_URL ?? "").Trim()
          if ([string]::IsNullOrWhiteSpace($url)) { throw "KF_AGENT_MSI_URL is empty after resolution step." }
          if (-not ($url -match '^https?://')) { throw "KF_AGENT_MSI_URL invalid: '$url'" }

          $msi = Join-Path $env:TEMP 'keyfactor-agent.msi'
          $log = Join-Path $env:TEMP 'kf-agent-install.log'

          Write-Host "‚¨áÔ∏è Downloading MSI:"
          Write-Host $url
          Invoke-WebRequest -Uri $url -OutFile $msi -UseBasicParsing
          Write-Host "‚úÖ Downloaded to $msi"
          Get-Item $msi | Format-List Name,Length,LastWriteTime

          Write-Host "üì¶ Installing MSI silently..."
          $p = Start-Process msiexec.exe -Wait -PassThru -ArgumentList "/i `"$msi`" /qn /norestart /l*v `"$log`""
          Write-Host "msiexec exit code: $($p.ExitCode)"
          if ($p.ExitCode -ne 0) {
            Write-Host "---- installer log tail ----"
            if (Test-Path $log) { Get-Content $log -Tail 200 }
            throw "MSI install failed with exit code $($p.ExitCode)"
          }

          Write-Host "‚úÖ MSI installed"

      - name: Configure agent (keyfactor-setup) and restart service
        shell: pwsh
        env:
          SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
          SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}
          SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
          SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          # Find keyfactor-setup.exe
          $kfCmd = Get-Command keyfactor-setup -ErrorAction SilentlyContinue
          $kf = if ($kfCmd) { $kfCmd.Path } else { $null }

          if (-not $kf) {
            $common = @(
              "C:\Program Files\Keyfactor\Agent\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\Service\keyfactor-setup.exe",
              "C:\Program Files\Keyfactor\keyfactor-setup.exe"
            )
            foreach ($p in $common) { if (Test-Path $p) { $kf = $p; break } }
          }

          if (-not $kf) {
            Write-Host "üîé Searching for keyfactor-setup.exe..."
            $found = Get-ChildItem -Path "C:\Program Files" -Filter "keyfactor-setup.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $kf = $found.FullName }
          }

          if (-not $kf) { throw "keyfactor-setup.exe not found after MSI install." }
          Write-Host "‚úÖ Using keyfactor-setup: $kf"

          & $kf `
            hostname="$env:SIGNUM_HOSTNAME" `
            clientid="$env:SIGNUM_CLIENTID" `
            username="$env:SIGNUM_USERNAME" `
            password="$env:SIGNUM_PASSWORD" `
            loglevel=HIGH logtype=FILE

          # Find Keyfactor service (name varies)
          $svc = Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Sort-Object Name | Select-Object -First 1
          if (-not $svc) {
            Get-Service | Where-Object { $_.Name -match 'keyfactor' -or $_.DisplayName -match 'keyfactor' } | Format-Table -AutoSize
            throw "No Keyfactor service found."
          }

          Write-Host "‚úÖ Restarting service: $($svc.Name) ($($svc.DisplayName))"
          Restart-Service -Name $svc.Name -Force
          Start-Sleep -Seconds 3
          $svc2 = Get-Service -Name $svc.Name
          Write-Host "Service status: $($svc2.Status)"
          if ($svc2.Status -ne 'Running') { throw "Service not running after restart." }

      - name: Verify file to sign exists
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (-not (Test-Path -Path $env:FILE_TO_SIGN)) {
            Write-Error "File to sign not found: $env:FILE_TO_SIGN"
            Get-ChildItem -Force
            exit 1
          }
          Write-Host "‚úÖ Signing: $env:FILE_TO_SIGN"
          Get-Item $env:FILE_TO_SIGN | Format-List

      - name: Find certificate thumbprint (by secret or subject)
        id: find_cert
        shell: pwsh
        env:
          CERT_THUMBPRINT_SECRET: ${{ secrets.CERT_THUMBPRINT || '' }}
          EXPECTED_SUBJECT_FRAGMENT: ${{ env.EXPECTED_SUBJECT_FRAGMENT }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not [string]::IsNullOrWhiteSpace($env:CERT_THUMBPRINT_SECRET)) {
            $tp = $env:CERT_THUMBPRINT_SECRET.Trim().Replace(' ','').ToUpper()
            Write-Host "‚úÖ Using thumbprint from secret: $tp"
            "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            exit 0
          }

          $frag = $env:EXPECTED_SUBJECT_FRAGMENT
          Write-Host "üîé Searching cert stores for subject containing: $frag"

          $found = $null
          foreach ($store in @('LocalMachine','CurrentUser')) {
            $certs = Get-ChildItem -Path "Cert:\$store\My" -ErrorAction SilentlyContinue
            foreach ($c in $certs) {
              if ($c.Subject -like "*$frag*") { $found = $c; break }
            }
            if ($found) { break }
          }

          if (-not $found) {
            Write-Host "‚ö†Ô∏è No matching cert found. Sample subjects:"
            Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host $_.Subject }
            throw "No certificate found matching '$frag'. Set secrets.CERT_THUMBPRINT to force selection."
          }

          $tp = $found.Thumbprint.Replace(' ','').ToUpper()
          Write-Host "‚úÖ Found cert: $($found.Subject)"
          Write-Host "Thumbprint: $tp"
          "thumbprint=$tp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Sign with signtool (preferred) or PowerShell fallback
        shell: pwsh
        env:
          THUMBPRINT: ${{ steps.find_cert.outputs.thumbprint }}
          TIMESTAMP_URL: ${{ secrets.TIMESTAMP_URL || 'http://timestamp.digicert.com' }}
        run: |
          $ErrorActionPreference = "Stop"

          $thumb = $env:THUMBPRINT
          if ([string]::IsNullOrWhiteSpace($thumb)) { throw "No thumbprint available." }

          $file = Resolve-Path -Path $env:FILE_TO_SIGN
          $sigtool = Get-Command signtool -ErrorAction SilentlyContinue

          if ($sigtool) {
            Write-Host "‚úçÔ∏è Using signtool"
            & signtool sign /sm /s My /sha1 $thumb /tr $env:TIMESTAMP_URL /td sha256 /fd sha256 $file
            if ($LASTEXITCODE -ne 0) { throw "signtool failed with exit $LASTEXITCODE" }
          } else {
            Write-Host "‚ö†Ô∏è signtool not found; using Set-AuthenticodeSignature"
            $cert = Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue | Where-Object { $_.Thumbprint -eq $thumb }
            if (-not $cert) { $cert = Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue | Where-Object { $_.Thumbprint -eq $thumb } }
            if (-not $cert) { throw "Could not load cert by thumbprint from either store." }

            $sig = Set-AuthenticodeSignature -FilePath $file -Certificate $cert -TimestampServer $env:TIMESTAMP_URL
            Write-Host "Signature status: $($sig.Status)"
          }

          $outdir = Join-Path $PWD $env:OUT_DIR
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          Copy-Item -Path $file -Destination (Join-Path $outdir (Split-Path $file -Leaf)) -Force
          Write-Host "‚úÖ Output:"
          Get-ChildItem $outdir | Format-Table

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-output
          path: signed-output/*
