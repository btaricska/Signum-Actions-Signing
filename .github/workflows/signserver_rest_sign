name: Sign Single JSON via SignServer (all-in-one)

on:
  workflow_dispatch:
    inputs:
      endpoint:
        description: "SignServer endpoint (optional override)"
        required: false
        type: string
  push:
    branches:
      - main

permissions: 
  contents: read

jobs:
  sign:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # if endpoint passed as workflow input, set it
      - name: Set endpoint from workflow input
        if: ${{ github.event.inputs.endpoint != '' }}
        run: echo "SIGNSERVER_ENDPOINT=${{ github.event.inputs.endpoint }}" >> $GITHUB_ENV

      # fallback to secret if no input provided
      - name: Set endpoint from secret (fallback)
        if: ${{ github.event.inputs.endpoint == '' }}
        run: |
          if [ -z "${{ secrets.SIGNSERVER_ENDPOINT || '' }}" ]; then
            echo "SIGNSERVER_ENDPOINT secret not set and no workflow input provided. Failing."
            exit 1
          fi
          echo "SIGNSERVER_ENDPOINT=${{ secrets.SIGNSERVER_ENDPOINT }}" >> $GITHUB_ENV

      - name: Debug: show endpoint and workspace
        run: |
          echo "SIGNSERVER_ENDPOINT=${SIGNSERVER_ENDPOINT}"
          echo "Workspace: $(pwd)"
          ls -la

      - name: Create JSON, POST to SignServer, save signature (PowerShell)
        shell: pwsh
        env:
          FILES_DIR: filestosign
          SIGNSERVER_ENDPOINT: ${{ env.SIGNSERVER_ENDPOINT }}
          TIMEOUT_SEC: 120
        run: |
          # Ensure endpoint exists
          if (-not $env:SIGNSERVER_ENDPOINT) {
            Write-Error "SIGNSERVER_ENDPOINT not set in environment. Aborting."
            exit 1
          }
          Write-Host "Using SignServer endpoint: $env:SIGNSERVER_ENDPOINT"

          # Ensure files folder
          if (-not (Test-Path -Path $env:FILES_DIR)) {
            New-Item -ItemType Directory -Path $env:FILES_DIR | Out-Null
            Write-Host "Created folder: $env:FILES_DIR"
          }

          # Create a small JSON file
          $sample = @{ message = "Hello from SignServer - $(Get-Date -Format u)" }
          $filePath = Join-Path $env:FILES_DIR "file.json"
          $sample | ConvertTo-Json -Depth 5 | Set-Content -Path $filePath -Encoding utf8
          Write-Host "Wrote sample JSON to $filePath"

          # Read file text (raw) and build payload matching your example
          $fileText = Get-Content -Path $filePath -Raw -Encoding utf8
          $payload = @{
            metaData = @{
              additionalProp1 = "value1"
              additionalProp2 = "value2"
              additionalProp3 = "value3"
            }
            filename = (Split-Path -Path $filePath -Leaf)
            data = $fileText
          } | ConvertTo-Json -Depth 10

          Write-Host "Sending POST to SignServer..."
          try {
            $resp = Invoke-RestMethod -Uri $env:SIGNSERVER_ENDPOINT -Method Post -Headers @{ 'Content-Type' = 'application/json' } -Body $payload -TimeoutSec ([int]$env:TIMEOUT_SEC) -ErrorAction Stop
            Write-Host "Request succeeded. Processing response..."
          } catch {
            Write-Error "REST call failed: $_"
            if ($_.Exception.Response -ne $null) {
              try {
                $errStream = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($errStream)
                $errBody = $reader.ReadToEnd()
                Write-Host "Server response: $errBody"
                $errBody | Out-File -FilePath "$filePath.sig.error" -Encoding utf8
              } catch {
                Write-Warning "Failed to read error response: $_"
              }
            }
            throw
          }

          # Attempt to extract signature
          $sigPath = "$filePath.sig"
          $sigJsonPath = "$filePath.sig.json"
          $wrote = $false

          if ($null -ne $resp) {
            # If JSON (PSCustomObject), try common fields
            if ($resp -is [System.Management.Automation.PSCustomObject]) {
              $candidates = @()
              if ($resp.PSObject.Properties.Name -contains 'signature') { $candidates += $resp.signature }
              if ($resp.PSObject.Properties.Name -contains 'sig')       { $candidates += $resp.sig }
              if ($resp.PSObject.Properties.Name -contains 'result') {
                try {
                  $r = $resp.result
                  if ($r -is [System.Management.Automation.PSCustomObject]) {
                    if ($r.PSObject.Properties.Name -contains 'signature') { $candidates += $r.signature }
                    if ($r.PSObject.Properties.Name -contains 'sig')       { $candidates += $r.sig }
                  }
                } catch {}
              }

              foreach ($c in $candidates) {
                if ($null -ne $c -and $c -is [string]) {
                  # base64? (basic heuristic)
                  if ($c -match '^[A-Za-z0-9\+/]+={0,2}$') {
                    try {
                      [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($c))
                      Write-Host "Saved signature to $sigPath (decoded from JSON field)"
                      $wrote = $true
                      break
                    } catch {
                      Write-Warning "Failed to base64-decode candidate signature: $_"
                    }
                  } else {
                    $c | Out-File -FilePath $sigPath -Encoding utf8
                    Write-Host "Saved signature to $sigPath (raw text from JSON field)"
                    $wrote = $true
                    break
                  }
                }
              }

              if (-not $wrote) {
                Write-Warning "No usable signature field in JSON response; saving full JSON to $sigJsonPath for inspection"
                $resp | ConvertTo-Json -Depth 10 | Out-File -FilePath $sigJsonPath -Encoding utf8
              }
            } else {
              # raw response string -> check base64
              $respString = [string]$resp
              if ($respString -and ($respString -match '^[A-Za-z0-9\+/]+={0,2}$')) {
                try {
                  [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($respString))
                  Write-Host "Saved signature to $sigPath (decoded from raw base64 response)"
                  $wrote = $true
                } catch {
                  Write-Warning "Response looked like base64 but decode failed: $_"
                }
              }
              if (-not $wrote) {
                $respString | Out-File -FilePath $sigPath -Encoding utf8
                Write-Host "Saved raw server response to $sigPath"
                $wrote = $true
              }
            }
          } else {
            Write-Warning "Server returned null response"
          }

          if (-not $wrote) {
            Write-Warning "Signature was not produced. Check $sigJsonPath or $filePath.sig.error for details."
            exit 1
          }

          Write-Host "Signature saved to: $sigPath"

      - name: Upload signature artifact
        uses: actions/upload-artifact@v4
        with:
          name: signature
          path: filestosign/file.json.sig
