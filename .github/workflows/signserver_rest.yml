name: Sign JSON via SignServer (bypass TLS validation - not restored)

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  sign:
    runs-on: ubuntu-latest

    env:
      SIGNSERVER_ENDPOINT: "https://signserverdemo.eastus2.cloudapp.azure.com/signserver/rest/v1/workers/PlainSigner/process"
      FILES_DIR: filestosign
      TIMEOUT_SEC: "120"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Create JSON and POST to SignServer (certificate validation bypassed, not restored)
        shell: pwsh
        run: |
          Write-Host "Using endpoint: $env:SIGNSERVER_ENDPOINT"
          $dir = $env:FILES_DIR
          if (-not (Test-Path -Path $dir)) { New-Item -ItemType Directory -Path $dir | Out-Null }

          # Create sample JSON
          $sample = @{ message = "Hello from GitHub Actions"; timestamp = (Get-Date -Format u) }
          $filePath = Join-Path $dir "file.json"
          $sample | ConvertTo-Json -Depth 5 | Set-Content -Path $filePath -Encoding utf8
          Write-Host "Wrote sample JSON to $filePath"

          # Prepare payload (sending raw text in "data" as you requested)
          $fileText = Get-Content -Path $filePath -Raw -Encoding utf8
          $payloadObj = @{
            metaData = @{
              additionalProp1 = "value1"
              additionalProp2 = "value2"
              additionalProp3 = "value3"
            }
            data = $fileText
          }
          $payload = $payloadObj | ConvertTo-Json -Depth 12

          # --- Build HttpClient that bypasses certificate validation (NOT RESTORED) ---
          $handler = New-Object System.Net.Http.HttpClientHandler
          $callback = { param($sender,$cert,$chain,$sslPolicyErrors) return $true }
          # ServerCertificateCustomValidationCallback expects a Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,bool>
          $handler.ServerCertificateCustomValidationCallback = $callback

          $client = [System.Net.Http.HttpClient]::new($handler)
          $client.Timeout = [System.TimeSpan]::FromSeconds([int]$env:TIMEOUT_SEC)

          try {
            Write-Host "Posting payload to SignServer (TLS cert validation disabled for this HttpClient)..."
            $content = New-Object System.Net.Http.StringContent($payload, [System.Text.Encoding]::UTF8, "application/json")
            $respMessage = $client.PostAsync($env:SIGNSERVER_ENDPOINT, $content).Result

            $respString = $respMessage.Content.ReadAsStringAsync().Result
            $respFile = "$filePath.response.json"
            $respString | Out-File -FilePath $respFile -Encoding utf8
            Write-Host "Saved full response to: $respFile (HTTP status: $($respMessage.StatusCode))"

            if (-not $respMessage.IsSuccessStatusCode) {
              Write-Error "SignServer returned HTTP $($respMessage.StatusCode). See $respFile for details."
              exit 1
            }

            # Try to parse JSON response
            $respObj = $null
            try { $respObj = $respString | ConvertFrom-Json } catch { }

            $sigPath = "$filePath.sig"
            $wrote = $false

            if ($respObj -ne $null) {
              # Try common fields
              if ($respObj.PSObject.Properties.Name -contains 'signature') { $candidate = $respObj.signature }
              elseif ($respObj.PSObject.Properties.Name -contains 'sig') { $candidate = $respObj.sig }
              else { $candidate = $null }

              if ($candidate -ne $null) {
                $candidate = [string]$candidate
                if ($candidate -match '^[A-Za-z0-9\+/]+={0,2}$') {
                  try {
                    [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($candidate))
                    Write-Host "Saved decoded signature to $sigPath"
                    $wrote = $true
                  } catch {
                    Write-Warning "Failed to decode base64 signature candidate: $_"
                  }
                } else {
                  $candidate | Out-File -FilePath $sigPath -Encoding utf8
                  Write-Host "Saved raw signature text to $sigPath"
                  $wrote = $true
                }
              }
            }

            if (-not $wrote) {
              # Response might be raw base64
              if ($respString -match '^[A-Za-z0-9\+/]+={0,2}$') {
                try {
                  [IO.File]::WriteAllBytes($sigPath, [Convert]::FromBase64String($respString))
                  Write-Host "Saved decoded signature to $sigPath (raw response)"
                  $wrote = $true
                } catch {
                  Write-Warning "Raw response looked like base64 but decode failed: $_"
                }
              }
            }

            if (-not $wrote) {
              # As final fallback, save raw response text to .sig
              $respString | Out-File -FilePath $sigPath -Encoding utf8
              Write-Host "Saved raw response text to $sigPath"
            }

          } catch {
            Write-Error "Exception during POST: $_"
            # Save error details if HTTP response present
            if ($_.Exception.Response -ne $null) {
              try {
                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                $err = $reader.ReadToEnd()
                $err | Out-File -FilePath "$filePath.sig.error" -Encoding utf8
                Write-Host "Saved error details to $filePath.sig.error"
              } catch {
                Write-Warning "Could not read exception response body: $_"
              }
            }
            exit 1
          } finally {
            # Note: we intentionally do NOT restore certificate validation here.
            Write-Host "Note: certificate validation remains bypassed for this runner process (NOT RESTORED)."
          }

      - name: Upload signature artifact
        uses: actions/upload-artifact@v4
        with:
          name: signature
          path: filestosign/file.json.sig
