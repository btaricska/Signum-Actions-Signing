name: Windows Code Signing (Keyfactor Agent)

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: windows-latest

    env:
      OUT_DIR: signed-output
      # You said you don't care what gets signed; we'll generate a file
      FILE_TO_SIGN: file-to-sign.bin
      EXPECTED_SUBJECT_FRAGMENT: CN=CodeSigningCertificate

      # MSI download + install
      MSI_LANGUAGE: en-US
      # You can override this with a secret if you want, but this works directly:
      KF_AGENT_MSI_URL: https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi

      # Required to satisfy MSI LaunchConditions
      SIGNUM_HOSTNAME: ${{ secrets.SIGNUM_HOSTNAME }}
      SIGNUM_CLIENTID: ${{ secrets.SIGNUM_CLIENTID }}

      # Used later if/when you have a non-interactive config tool; safe to keep
      SIGNUM_USERNAME: ${{ secrets.SIGNUM_USERNAME }}
      SIGNUM_PASSWORD: ${{ secrets.SIGNUM_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show PowerShell
        shell: pwsh
        run: |
          $PSVersionTable
          Write-Host "RUNNER_TEMP: $env:RUNNER_TEMP"
          Write-Host "GITHUB_WORKSPACE: $env:GITHUB_WORKSPACE"

      - name: Prepare output folder
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) | Out-Null

      - name: Create a random file to sign
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $outDir = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          $path   = Join-Path $outDir $env:FILE_TO_SIGN

          # 64KB of random bytes
          $bytes = New-Object byte[] (64kb)
          [System.Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($bytes)
          [System.IO.File]::WriteAllBytes($path, $bytes)

          Write-Host "Created file to sign: $path"
          Get-Item $path | Format-List FullName,Length

      - name: Download Keyfactor Agent MSI (curl)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          if ([string]::IsNullOrWhiteSpace($env:KF_AGENT_MSI_URL)) {
            throw "KF_AGENT_MSI_URL is empty."
          }

          $msiPath = Join-Path $env:RUNNER_TEMP "kf-agent.msi"
          $logPath = Join-Path $env:RUNNER_TEMP "kf-agent-install.log"

          "MSI_PATH=$msiPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "MSI_LOG=$logPath"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          Write-Host "Downloading MSI with curl..."
          Write-Host "  URL:  $env:KF_AGENT_MSI_URL"
          Write-Host "  OUT:  $msiPath"

          curl.exe -L -o "$msiPath" "$env:KF_AGENT_MSI_URL"

          if (-not (Test-Path $msiPath)) { throw "MSI download failed: $msiPath" }
          Write-Host "Downloaded MSI size: $((Get-Item $msiPath).Length) bytes"

      - name: Install Keyfactor Agent MSI (with required properties)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          function Tail-File([string]$Path, [int]$Lines = 200) {
            if (Test-Path $Path) {
              Write-Host "---- Tail($Lines): $Path ----"
              Get-Content -Path $Path -Tail $Lines | ForEach-Object { Write-Host $_ }
            }
          }

          if ([string]::IsNullOrWhiteSpace($env:SIGNUM_HOSTNAME)) { throw "Missing SIGNUM_HOSTNAME secret/env" }
          if ([string]::IsNullOrWhiteSpace($env:SIGNUM_CLIENTID)) { throw "Missing SIGNUM_CLIENTID secret/env" }

          $msiPath = $env:MSI_PATH
          $logPath = $env:MSI_LOG
          $lang    = if ([string]::IsNullOrWhiteSpace($env:MSI_LANGUAGE)) { "en-US" } else { $env:MSI_LANGUAGE }

          Write-Host "Installing MSI..."
          Write-Host "  MSI_PATH  = $msiPath"
          Write-Host "  MSI_LOG   = $logPath"
          Write-Host "  RTPRIMARY = $env:SIGNUM_HOSTNAME"
          Write-Host "  CLIENTID  = (hidden)"
          Write-Host "  LANGUAGE  = $lang"

          $args = @(
            "/i", "`"$msiPath`"",
            "RTPRIMARY=`"$($env:SIGNUM_HOSTNAME)`"",
            "CLIENTID=`"$($env:SIGNUM_CLIENTID)`"",
            "LANGUAGE=`"$lang`"",
            "/qn",
            "/norestart",
            "/l*v", "`"$logPath`""
          )

          $p = Start-Process -FilePath "msiexec.exe" -ArgumentList $args -Wait -PassThru
          Write-Host "msiexec exit code: $($p.ExitCode)"

          if ($p.ExitCode -ne 0) {
            Tail-File -Path $logPath -Lines 400
            throw "MSI install failed (exit code $($p.ExitCode))."
          }

      - name: Show what the MSI installed (KeyFactor folder)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          $path = "C:\Program Files\KeyFactor"
          if (Test-Path $path) {
            Write-Host "Listing: $path"
            Get-ChildItem -Path $path -Force | Select-Object Name,Length,LastWriteTime | Format-Table -AutoSize
          } else {
            Write-Host "KeyFactor folder not found at: $path"
          }

      - name: Restart Keyfactor-ish service (best effort, never fail on access denied)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          Set-StrictMode -Version Latest

          try {
            $svcs = Get-CimInstance Win32_Service -ErrorAction Stop
          } catch {
            Write-Host "Unable to enumerate services via CIM: $($_.Exception.Message)"
            return
          }

          $candidates = $svcs |
            Where-Object {
              $_.Name -match 'keyfactor|signum|redtrust' -or
              $_.DisplayName -match 'keyfactor|signum|redtrust'
            } |
            Sort-Object Name

          if (-not $candidates -or $candidates.Count -eq 0) {
            Write-Host "No Keyfactor-ish service found to restart (continuing)."
            return
          }

          $svc = $candidates | Select-Object -First 1
          Write-Host "Attempting restart: $($svc.Name) ($($svc.DisplayName))"

          try {
            Restart-Service -Name $svc.Name -Force -ErrorAction Stop
            Start-Sleep -Seconds 3
          } catch {
            Write-Host "Restart blocked/failed (continuing): $($_.Exception.Message)"
          }

          try {
            $state = (Get-CimInstance Win32_Service -Filter "Name='$($svc.Name)'" -ErrorAction SilentlyContinue).State
            Write-Host "Service state: $state"
          } catch {}

      - name: Sign file (signtool - placeholder)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          if (-not (Test-Path $file)) { throw "File not found: $file" }

          if (-not (Get-Command signtool.exe -ErrorAction SilentlyContinue)) {
            throw "signtool.exe not found on PATH. Install Windows SDK OR use the agent's signing integration/CLI."
          }

          Write-Host "Signing: $file"
          & signtool.exe sign /fd sha256 /tr http://timestamp.digicert.com /td sha256 "$file"

      - name: Verify Authenticode signature
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $file = Join-Path (Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR) $env:FILE_TO_SIGN
          $sig = Get-AuthenticodeSignature -FilePath $file

          Write-Host "Signature status: $($sig.Status)"
          if ($sig.SignerCertificate) {
            Write-Host "Signer subject: $($sig.SignerCertificate.Subject)"
          }

          if ($sig.Status -ne "Valid") { throw "Signature not valid: $($sig.Status)" }

          $subject = $sig.SignerCertificate.Subject
          if ($subject -notlike "*$($env:EXPECTED_SUBJECT_FRAGMENT)*") {
            throw "Signer subject does not contain expected fragment '$($env:EXPECTED_SUBJECT_FRAGMENT)'. Actual: '$subject'"
          }

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-output
          path: ${{ env.OUT_DIR }}
          if-no-files-found: error
