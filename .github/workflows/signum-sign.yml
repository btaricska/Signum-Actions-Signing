name: Windows Code Signing (Keyfactor Agent)

on:
  workflow_dispatch:
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  sign:
    runs-on: windows-latest

    env:
      OUT_DIR: signed-output

      # Agent MSI
      MSI_LANGUAGE: en-US
      MSI_PATH: kf-agent.msi
      MSI_LOG:  kf-agent-install.log

      # Public MSI URL (you said this works)
      KF_AGENT_MSI_URL: https://kfsaas0167ead7.blob.core.windows.net/signum-public/agents/windows/4.40.1/kf-agent-x64-4.40.1-ffb85044-MS-WO_Trust.msi

      # Required for MSI install + agent config
      SIGNUM_HOSTNAME:  ${{ secrets.SIGNUM_HOSTNAME }}
      SIGNUM_CLIENTID:  ${{ secrets.SIGNUM_CLIENTID }}
      SIGNUM_USERNAME:  ${{ secrets.SIGNUM_USERNAME }}
      SIGNUM_PASSWORD:  ${{ secrets.SIGNUM_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare output folder
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "${env:OUT_DIR}" | Out-Null

      - name: Create random file to sign
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $outDir = Join-Path $env:GITHUB_WORKSPACE $env:OUT_DIR
          $file = Join-Path $outDir "file-to-sign.bin"

          # 512KB random file
          $bytes = New-Object byte[] (512 * 1024)
          [System.Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($bytes)
          [System.IO.File]::WriteAllBytes($file, $bytes)

          "FILE_TO_SIGN=$file" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Created file to sign: $file"

      - name: Download Keyfactor Agent MSI (curl)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          if ([string]::IsNullOrWhiteSpace($env:KF_AGENT_MSI_URL)) {
            throw "KF_AGENT_MSI_URL is empty."
          }

          Write-Host "Downloading MSI -> $env:MSI_PATH"
          curl.exe -L -o "$env:MSI_PATH" "$env:KF_AGENT_MSI_URL"

          if (-not (Test-Path "$env:MSI_PATH")) { throw "MSI download failed." }
          Write-Host "Downloaded MSI size: $((Get-Item $env:MSI_PATH).Length) bytes"

      - name: Install Keyfactor Agent MSI (with required properties)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          function Tail-File([string]$Path, [int]$Lines = 250) {
            if (Test-Path $Path) {
              Write-Host "---- Tail($Lines): $Path ----"
              Get-Content -Path $Path -Tail $Lines | ForEach-Object { Write-Host $_ }
            }
          }

          foreach ($n in @("SIGNUM_HOSTNAME","SIGNUM_CLIENTID")) {
            $v = (Get-Item -Path "Env:$n" -ErrorAction SilentlyContinue).Value
            if ([string]::IsNullOrWhiteSpace($v)) { throw "Missing env var: $n" }
          }

          $rtPrimary = $env:SIGNUM_HOSTNAME
          $clientId  = $env:SIGNUM_CLIENTID
          $lang      = if ([string]::IsNullOrWhiteSpace($env:MSI_LANGUAGE)) { "en-US" } else { $env:MSI_LANGUAGE }

          $args = @(
            "/i", "`"$env:MSI_PATH`"",
            "RTPRIMARY=`"$rtPrimary`"",
            "CLIENTID=`"$clientId`"",
            "LANGUAGE=`"$lang`"",
            "/qn",
            "/norestart",
            "/l*v", "`"$env:MSI_LOG`""
          )

          Write-Host "Installing MSI..."
          Write-Host "  RTPRIMARY=$rtPrimary"
          Write-Host "  CLIENTID=$clientId"
          Write-Host "  LANGUAGE=$lang"

          $p = Start-Process -FilePath "msiexec.exe" -ArgumentList $args -Wait -PassThru
          Write-Host "msiexec exit code: $($p.ExitCode)"

          if ($p.ExitCode -ne 0) {
            Tail-File -Path $env:MSI_LOG -Lines 400
            throw "MSI install failed (exit code $($p.ExitCode))."
          }

      - name: Optional agent config tool (best-effort)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          Set-StrictMode -Version Latest

          Write-Host "=== Find optional setup/config tool ==="
          $candidates = @(
            "C:\Program Files\KeyFactor\keyfactor-setup.exe",
            "C:\Program Files\KeyFactor\rtkspconfig.exe"
          )

          $tool = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $tool) {
            Write-Host "No known setup/config tool found. Continuing."
            exit 0
          }

          Write-Host "Found setup/config tool: $tool"
          Write-Host "Not auto-running unknown tools in CI. Continuing."

      - name: Restart Keyfactor services (best-effort, avoid PermissionDenied)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Continue"
          Set-StrictMode -Version Latest

          Write-Host "=== Restart service (if any) ==="

          $svcs = @()
          try {
            $svcs = Get-Service -ErrorAction Stop |
              Where-Object { $_.Name -match 'keyfactor|signum|redtrust' -or $_.DisplayName -match 'keyfactor|signum|redtrust' } |
              Sort-Object Name
          } catch {
            Write-Host "Get-Service failed (non-fatal): $($_.Exception.Message)"
            exit 0
          }

          if (-not $svcs -or $svcs.Count -eq 0) {
            Write-Host "No matching services found. Continuing."
            exit 0
          }

          foreach ($svc in $svcs) {
            try {
              Write-Host "Restarting: $($svc.Name) ($($svc.DisplayName))"
              Restart-Service -Name $svc.Name -Force -ErrorAction Stop
            } catch {
              Write-Host "Could not restart $($svc.Name) (non-fatal): $($_.Exception.Message)"
            }
          }

      - name: Locate signtool.exe (prefer x64)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $candidates = @(
            "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe",
            "C:\Program Files (x86)\Windows Kits\10\bin\*\x86\signtool.exe"
          )

          $signtool = Get-ChildItem -Path $candidates -ErrorAction SilentlyContinue |
            Sort-Object FullName -Descending |
            Select-Object -First 1

          if (-not $signtool) {
            throw "signtool.exe not found. Windows SDK not present."
          }

          "SIGNTOOL=$($signtool.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Using signtool: $($signtool.FullName)"

      - name: Find code signing cert (CurrentUser then LocalMachine) + choose thumbprint
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $codeSigningOid = "1.3.6.1.5.5.7.3.3"

          function Has-CodeSigningEku($cert) {
            try {
              foreach ($ext in $cert.Extensions) {
                if ($ext.Oid -and $ext.Oid.Value -eq "2.5.29.37") {
                  $eku = New-Object System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension($ext, $false)
                  foreach ($oid in $eku.EnhancedKeyUsages) {
                    if ($oid.Value -eq $codeSigningOid) { return $true }
                  }
                }
              }
            } catch { }
            return $false
          }

          $stores = @("Cert:\CurrentUser\My","Cert:\LocalMachine\My")
          $rows = @()

          foreach ($store in $stores) {
            $certs = @()
            try {
              $certs = Get-ChildItem -Path $store -ErrorAction Stop
            } catch {
              Write-Host "Could not read $store: $($_.Exception.Message)"
              continue
            }

            foreach ($c in $certs) {
              if (Has-CodeSigningEku $c) {
                $rows += [PSCustomObject]@{
                  Store      = $store
                  CN         = (($_.Subject -split ',\s*' | Select-Object -First 1) -replace '^CN=','')
                  Thumbprint = $c.Thumbprint
                  NotAfter   = $c.NotAfter
                  HasKey     = $c.HasPrivateKey
                  Subject    = $c.Subject
                }
              }
            }
          }

          $data = $rows | Sort-Object -Property `
            @{ Expression = "HasKey";   Descending = $true }, `
            @{ Expression = "NotAfter"; Descending = $true }

          $data | ConvertTo-Json -Depth 100 | Out-File -FilePath "cert_data.json" -Encoding utf8
          Write-Host "=== cert_data.json ==="
          Get-Content .\cert_data.json | Write-Host

          if (-not $data -or $data.Count -eq 0) {
            Write-Host "No Code Signing certs found in CurrentUser or LocalMachine stores."
            throw "No Code Signing certs found"
          }

          $chosen = $data | Where-Object { $_.HasKey } | Select-Object -First 1
          if (-not $chosen) { $chosen = $data | Select-Object -First 1 }

          "SIGNING_THUMBPRINT=$($chosen.Thumbprint)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Chosen Store: $($chosen.Store)"
          Write-Host "Chosen CN: $($chosen.CN)"
          Write-Host "Chosen thumbprint: $($chosen.Thumbprint)"
          Write-Host "HasPrivateKey: $($chosen.HasKey)"
          Write-Host "Expires: $($chosen.NotAfter)"

      - name: Sign the file (by thumbprint)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $signtool = $env:SIGNTOOL
          if (-not (Test-Path $signtool)) { throw "SIGNTOOL path invalid: $signtool" }

          $file = $env:FILE_TO_SIGN
          if (-not (Test-Path $file)) { throw "FILE_TO_SIGN not found: $file" }

          $thumb = $env:SIGNING_THUMBPRINT
          if ([string]::IsNullOrWhiteSpace($thumb)) { throw "SIGNING_THUMBPRINT is empty" }

          Write-Host "Signing: $file"
          & $signtool sign `
            /sha1 "$thumb" `
            /fd sha256 `
            /tr http://timestamp.digicert.com `
            /td sha256 `
            "$file"

      - name: Verify signature
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Set-StrictMode -Version Latest

          $file = $env:FILE_TO_SIGN
          $sig = Get-AuthenticodeSignature -FilePath $file

          Write-Host "Signature status: $($sig.Status)"
          if ($sig.SignerCertificate) {
            Write-Host "Signer subject: $($sig.SignerCertificate.Subject)"
            Write-Host "Signer thumbprint: $($sig.SignerCertificate.Thumbprint)"
          }

          if ($sig.Status -ne "Valid") {
            throw "Signature not valid: $($sig.Status)"
          }

      - name: Upload signed artifact
        uses: actions/upload-artifact@v4
        with:
          name: signed-output
          path: ${{ env.OUT_DIR }}
          if-no-files-found: error
